//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : GotoCommand.cpp
//  @ Date : 2019-06-27
//  @ Author : ShunWang
//
//


#include "GotoCommand.h"
#include "Transaction/Motor.h"
#include "Transaction/Robot.h"
#include "Driver/MyLog4CXX.h"

const std::string LOG_TAG("root.GotoCommand::");

int GotoCommand::exec()
{
    auto logger = initLogger(LOG_TAG + std::string(__FUNCTION__));
	//解析JSON参数
    int pos = _paraJson["pos"].asInt();
    int rotateEnable = _paraJson["rotateEnable"].asInt();
    Motor *pMotor = Motor::getInstance();
    Robot *pRobot = Robot::getInstance();
    static int reachRetry = 0;

    Json::Value *sharedJson = getSharedParaJson();
    if(sharedJson == NULL) {
        printf("GotoCommand::%s(), can't get json value!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " can't get json value! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }
    (*sharedJson)[JSON_EXEC_RESULT] = ST_FAIL;

	if(_exeRet != ST_SUCCESS && _exeRet != ST_FAIL)
	{
	    switch(_exeStatus)
		{
			case GOTO_ST_SNDCMD:
			{
/*                 if(rotateEnable) {
                    float curPos = pMotor->getCurPosition();
                    int presetNumber = 0;
                    int nRet = pRobot->m_pIndustrialCamera->connect();
                    if(nRet == 0) {
                        if( curPos - pos < -100) {          //前进
                            presetNumber = 1;
                            pRobot->m_pIndustrialCamera->presetOperation(GOTO_PRESET, presetNumber);
			    			// pMotor->armMoveTo(0);
                        }
                        else if( curPos - pos > 100 ) {     //后退
                            presetNumber = 2;
                            pRobot->m_pIndustrialCamera->presetOperation(GOTO_PRESET, presetNumber);
			    			// pMotor->armMoveTo(0);
                        }
                    }
                }
                else {
                    // pMotor->armMoveTo(0);
                } */
                int nRet = pMotor->goTo(pos);
                printf("GotoCommand::%s(), go to %d, nRet: %d\n", __FUNCTION__, pos, nRet);
	            LOG4CPLUS_INFO(logger, " go to " << pos << ", nRet: " << nRet);
				if(nRet == RET_SUCCESS) {
					_tryCnt = 0;
                    clearTimer();
	                _exeStatus = GOTO_ST_WAITRESULT;
				}
				else {
	                if(_tryCnt <= 5) {
                        printf("GotoCommand::%s(), go to %d failed, try again!\n", __FUNCTION__, pos);
	            		LOG4CPLUS_INFO(logger, " go to " << pos << " failed, try again!");
                        _tryCnt++;
					}
					else {
                        printf("GotoCommand::%s(), go to %d failed, exit!\n", __FUNCTION__, pos);
						LOG4CPLUS_ERROR(logger, " go to " << pos << " failed, exit!");
						setExeRet(ST_FAIL); 
					}
				}
				break;
			}
			case GOTO_ST_WAITRESULT:
			{
                if(0 != sleeepWaitTimeOut(10)) { break; }
				if(STOP_STATE == pMotor->getCurStatus()) //当前状态为停止
				{
                    float curPos = pMotor->getCurPosition();
	                if(abs(pos - curPos) < 250) //当前位置误差小于25CM
					{
                        (*sharedJson)[JSON_EXEC_RESULT] = ST_SUCCESS;
						LOG4CPLUS_INFO(logger, " GotoCmd succeeded to excute! " );
						setExeRet(ST_SUCCESS);		
                        reachRetry = 0;
					}
					else  //停住位置错误
					{
                        if (reachRetry <= 5) {
                            printf("GotoCommand::%s(), does not reach target, cur pos: %f, target pos: %d, retry: %d\n", __FUNCTION__, curPos, pos, reachRetry);
                            LOG4CPLUS_ERROR(logger, " does not reach target, cur pos: " << curPos << ", target pos: " << pos << ", retry: " << reachRetry);
                            _tryCnt = 0;
                            clearTimer();
                            _exeStatus = GOTO_ST_SNDCMD;
                            reachRetry++;
                        }
                        else {
                            (*sharedJson)[JSON_EXEC_RESULT] = ST_SUCCESS;
                            printf("GotoCommand::%s(), retry failed, exit!\n", __FUNCTION__);
                            LOG4CPLUS_ERROR(logger, " retry failed, exit!");
                            reachRetry = 0;
                            setExeRet(ST_FAIL);	
                        }
					}
				}
				break;
			}
			default:
			{
				break;
			}
			
		}
	}
	return _exeRet;
}

