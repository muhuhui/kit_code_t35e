//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : MoveTaskManage.cpp
//  @ Date : 2019-06-25
//  @ Author : ShunWang
//
//


#include "MoveTaskManage.h"
#include "MoveTask.h"
#include "MoveTaskItem.h"
#include "RFIDService.h"
#include "Transaction/Motor.h"
#include "MoveException.h"
#include "Transaction/Robot.h"
#include <assert.h>
#include <iostream>
#include <typeinfo>
#include "Driver/MyLog4CXX.h"
#include "Transaction/Capabilities.h"

const std::string LOG_TAG("root.MoveTaskManage::");

std::mutex g_taskMtx;
ViewPointInfo patrolViewPointInfo;
int videoflag = 0;

int extratNum(string str)
{
	const char* a = str.c_str();
	int cnt_int = 0;
	//cnt_int 用于存放字符串中的数字.

	for (int i = 0; a[i] != '\0'; ++i) //当a数组元素不为结束符时.遍历字符串a.
	{
		if (a[i] >= '0'&& a[i] <= '9') //如果是数字.
		{
			cnt_int *= 10;//先乘以10保证先检测到的数字存在高位，后检测的存在低位
			cnt_int += a[i] - '0'; //数字字符的ascii-字符'0'的ascii码就等于该数字.
		}
	}
	cout << cnt_int << endl; //输出数字.(12345)
	return cnt_int;
}

//添加运动前收机械臂命令
bool addLiftingArmCmd(bool isSetting
	, MoveTaskComponent *sharedParent
	, MoveTaskItem* taskItem
	, int dis = 10)
{
	if (isSetting)
	{
		Json::Value req;
		req["ctrl"] = Motion_Arm_MoveTo;
		//req["value"] = SettingService::getInstance()->m_setting.getArmBeginPos() + dis;
		req["value"] = dis;
		MoveControlCommand* p_iMCC = new MoveControlCommand;
		p_iMCC->setParaJson(req);
		p_iMCC->setSharedParent(sharedParent);
		taskItem->addCommand(p_iMCC);
		return true;
	}
	else
	{
		return false;
	}
}

void MoveTaskManage::process(MoveTaskManage* moveTaskManage)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
	moveTaskManage->setCurTaskItem(NULL);
	while (1)
	{
		g_taskMtx.lock();

		//清理僵尸动作组
		MoveTaskItem* curMoveTaskItem = moveTaskManage->getCurTaskItem();
		if (NULL != curMoveTaskItem && curMoveTaskItem->_commands.size() == 0) //当前动作组命令执行完毕，删除此项任务
		{
			if (curMoveTaskItem->isActive()) {       //任务仍在进行，则异常处理退出
				printf("--- MoveTaskManage::%s(), curMoveTaskItem = %p, __LINE__= %d: exceptions exit.\n", __FUNCTION__, curMoveTaskItem, __LINE__);
				LOG4CPLUS_INFO(logger, " curMoveTaskItem = " << curMoveTaskItem << " : exceptions exit.");
				curMoveTaskItem->exceptionsExit();
			}

			printf("--- MoveTaskManage::%s(), curMoveTaskItem = %p, __LINE__= %d: item clear.\n", __FUNCTION__, curMoveTaskItem, __LINE__);
			LOG4CPLUS_INFO(logger, " curMoveTaskItem = " << curMoveTaskItem << " : item clear.");
			MoveTaskComponent::iterativeDelete(curMoveTaskItem); //没有命令项，丢掉此项任务
			moveTaskManage->setCurTaskItem(NULL);
			curMoveTaskItem = NULL;
		}
		if (SettingService::getInstance()->m_setting.getMotorLock() == true) //锁定不执行任务
		{
			//清除手动任务
			printf("--- MoveTaskManage::%s(), curMoveTaskItem = %p, __LINE__= %d: exceptions lock.\n", __FUNCTION__, curMoveTaskItem, __LINE__);
			LOG4CPLUS_INFO(logger, " curMoveTaskItem = " << curMoveTaskItem << " : exceptions lock.");
			moveTaskManage->clearTaskCommandsExceptPatroPlan(&moveTaskManage->_rootTasks[TP_MANUL]);
			moveTaskManage->setCurTaskItem(NULL);

			g_taskMtx.unlock();
			usleep(200000); //休眠0.2s
			continue;
		}
		MoveTaskItem *moveTaskItem = moveTaskManage->queryHighestPrioriyTaskItem(curMoveTaskItem);
		if (NULL != moveTaskItem)
		{
			if (moveTaskItem == moveTaskManage->getCurTaskItem()) //当前任务组为优先级最高的任务组
			{
				LOG4CPLUS_INFO(logger, " tag=regular curMoveTaskItem = " << moveTaskItem << " : item in.");
				moveTaskItem->run();
				LOG4CPLUS_INFO(logger, " tag=regular curMoveTaskItem = " << moveTaskItem << " : item out.");
			}
			else
			{
				printf("--- MoveTaskManage::%s(), curMoveTaskItem = %p, __LINE__= %d: item start.\n", __FUNCTION__, moveTaskItem, __LINE__);
				LOG4CPLUS_INFO(logger, " curMoveTaskItem = " << moveTaskItem << " : item start.");
				moveTaskItem->initStatusPara();
				moveTaskManage->setCurTaskItem(moveTaskItem);
				g_taskMtx.unlock();
				continue;
			}
		}

		g_taskMtx.unlock();
		usleep(20000); //休眠20ms
	}
}

//定期任务老化
void MoveTaskManage::regularTaskAgingCheck(MoveTaskManage* moveTaskManage)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	printf("--- MoveTaskManage::%s() start\n", __FUNCTION__);
	LOG4CPLUS_INFO(logger, " start. ");
	std::vector<MoveTaskComponent *> taskComponents;
	std::vector<MoveTaskComponent *>::iterator it;
	while (1)
	{
		sleep(10);          //等待切换模式后清除完任务
		RunMode curRunMode = SettingService::getInstance()->m_setting.getRunMode();
		LOG4CPLUS_INFO(logger, " tag=regular curRunMode " << (int)curRunMode);
		if (curRunMode == TASK_MODE) {       //只有任务模式才会执行定时任务
			taskComponents = moveTaskManage->_rootTasks[TP_REGULAR].getTaskComponents();
			LOG4CPLUS_INFO(logger, " tag=regular task size " << (int)taskComponents.size());
			int icount = 0;
			for (it = taskComponents.begin(); it != taskComponents.end(); it++)
			{
				LOG4CPLUS_INFO(logger, " tag=regular task time icount " << icount++);
				if ((*it)->cacuSurvivalTime() > 10l)         //定时任务老化时间超过1个小时
				{
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 1 ");
					g_taskMtx.lock();
					moveTaskManage->clearTaskCommands(*it);
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 2 ");

					MoveTaskItem* curTaskItem = (MoveTaskItem*)((*it)->findLeftMostChild());
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 3 ");

					if (curTaskItem->isActive()) {       //对所有正在运行的任务进行异常退出处理
						printf("--- MoveTaskManage::%s(), curMoveTaskItem = %p, __LINE__= %d: exceptions exit.\n", __FUNCTION__, curTaskItem, __LINE__);
						LOG4CPLUS_INFO(logger, " curMoveTaskItem = " << curTaskItem << " : exceptions exit.");
						LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 4 ");

						curTaskItem->exceptionsExit();
						LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 5 ");

					}
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 6 ");

					MoveTaskComponent::iterativeDelete(*it);
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 6_1 ");
					if (moveTaskManage->getCurTaskItem() == curTaskItem) {      //如果正在运行，则改为不运行
						moveTaskManage->setCurTaskItem(NULL);
						LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 7 ");

					}
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 8 ");

					g_taskMtx.unlock();
					LOG4CPLUS_INFO(logger, " tag=regular task regular timeout 9 ");

					printf("--- MoveTaskManage::%s(), curMoveTask = %p, __LINE__= %d: clear task.\n", __FUNCTION__, (*it), __LINE__);
					LOG4CPLUS_INFO(logger, "tas=regular  curMoveTaskItem = " << (*it) << " : clear task.");

					//sleep(20000);
				}
			}
		}
	}
	printf("--- MoveTaskManage::%s() end\n", __FUNCTION__);
	LOG4CPLUS_INFO(logger, " end. ");
}

void MoveTaskManage::addTask(MoveTask *task, int priority)
{
	_rootTasks[priority].add(task);
}

void MoveTaskManage::addTaskItem(MoveTaskItem *taskItem, int priority)
{
	_rootTasks[priority].add(taskItem);
}

void MoveTaskManage::init()
{
	moveException = MoveException::getInstance();
	for (int i = 0; i < TP_TOTAL; i++)
	{
		_rootTasks[i].init();
	}
	//初始化运动异常类
	moveException->init();
}

void MoveTaskManage::setCurTaskItem(MoveTaskItem *curTaskItem)
{
	_curTaskItem = curTaskItem;
}

MoveTaskItem* MoveTaskManage::getCurTaskItem()
{
	return _curTaskItem;
}

int MoveTaskManage::getManualItemSize()
{
	return _rootTasks[TP_MANUL].getChildSize();
}

//按优先级轮询任务
MoveTaskItem* MoveTaskManage::queryHighestPrioriyTaskItem(MoveTaskItem* curTaskItem)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	static RunMode lastRunMode = NONE_MODE;
	RunMode curRunMode = SettingService::getInstance()->m_setting.getRunMode();
	if (curRunMode != lastRunMode) {                     //切换模式后清空累计的任务
		clearTaskCommands(&_rootTasks[TP_MANUL]);
		clearTaskCommands(&_rootTasks[TP_PLAN]);
		clearTaskCommands(&_rootTasks[TP_REGULAR]);
		if (curTaskItem != NULL) {                       //切换模式时异常处理切换前模式任务
			if (curTaskItem->isActive()) {
				curTaskItem->exceptionsExit();
			}
		}
		if (Motor::getInstance()->getCurStatus() != STOP_STATE) {     //电机仍运动时停止电机
			Motor::getInstance()->emergencyStop();
		}
		printf("--- MoveTaskManage::%s(), __LINE__ = %d, run mode change from %d to %d\n", __FUNCTION__, __LINE__, lastRunMode, curRunMode);
		LOG4CPLUS_INFO(logger, " run mode change from " << lastRunMode << " to " << curRunMode);
		lastRunMode = curRunMode;
		setCurTaskItem(NULL);                           //切换后重新分配任务
	}
	for (int i = 0; i < TP_TOTAL; i++)
	{
		MoveTaskItem * moveTaskItem = (MoveTaskItem *)_rootTasks[i].findLeftMostChild();
		if (curRunMode == TASK_MODE) {                   //任务模式，不执行远程遥控
			if (i == TP_MANUL && moveTaskItem != NULL &&
				((moveTaskItem->m_itemType != PATRO_PLAN_ITEM) &&
				(moveTaskItem->m_itemType != PATRO_PLAN_CHARGE_ITEM) &&
					(moveTaskItem->m_itemType != POWER_ON_PLAN_ITEM))) {
				continue;
			}
		}
		else if (curRunMode == REMOTE_CONTROL_MODE) {    //远程遥控模式，不执行定时任务
			if (i == TP_REGULAR) {
				continue;
			}
		}
		else if (curRunMode == HANDLE_CONTROL_MODE) {    //手持遥控，暂不支持
			continue;
		}
		else if (curRunMode == SCAN_MODE) {              //扫描模式，只执行远程遥控
			if (i != TP_MANUL) {
				continue;
			}
		}
		else {                                          //没有此模式，不执行
			printf("MoveTaskManage::%s(), no this mode!\n", __FUNCTION__);
			LOG4CPLUS_INFO(logger, " no this mode! ");
			return NULL;
		}
		if (moveException->getForewardUSSExcep() ||
			moveException->getBackUSSExcep()) {
			if (i == TP_REGULAR) {
				continue;
			}
			else if (i == TP_MANUL && moveTaskItem != NULL &&
				(moveTaskItem->m_itemType == PATRO_PLAN_ITEM ||
					moveTaskItem->m_itemType == PATRO_PLAN_CHARGE_ITEM ||
					moveTaskItem->m_itemType == POWER_ON_PLAN_ITEM)) {
				continue;
			}
		}
		if (NULL != moveTaskItem)
		{
			return moveTaskItem;
		}
	}
	return NULL;
}

MoveTaskManage* MoveTaskManage::getInstance()
{
	return SingleTon<MoveTaskManage>::GetInstance();
}

//创建充电命令组
MoveTaskItem* MoveTaskManage::createChargeTaskItem(float destPos, ItemType itemType, RECHARGE_TYPE chargeType, string destPosName)
{
	Robot* pRobot = Robot::getInstance();
	Json::Value req;
	MoveTaskItem* moveTaskItem = new MoveTaskItem(itemType);
	moveTaskItem->initStatusPara();
	req.clear();

	SetSpeedCommand *setSpeedCommand = new SetSpeedCommand();
	req["speed"] = SettingService::getInstance()->m_setting.getDefaultSpeed();
	setSpeedCommand->setParaJson(req);
	moveTaskItem->addCommand(setSpeedCommand);
	req["charge_type"] = chargeType;

	if (pRobot->m_pCapabilities->isSupportPtzMotor()) {
		PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
		req["x_pos"] = 0;
		req["y_pos"] = 0;
		req["z_pos"] = 0;
		req["zoom"] = 0;
		req["isReturn"] = 1;
		ptzRotateCommand->setParaJson(req);
		ptzRotateCommand->setSharedParent(moveTaskItem);
		moveTaskItem->addCommand(ptzRotateCommand);
	}

	if (pRobot->m_pCapabilities->isSupportArmMotor()) {
		addLiftingArmCmd(true
			, moveTaskItem
			, moveTaskItem);
	}

	req["destPos"] = destPos;
	req["destPosName"] = destPosName;

	if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
		T7AChargeCommand* chargeCommand = new T7AChargeCommand();
		chargeCommand->setParaJson(req);
		chargeCommand->setSharedParent(moveTaskItem);
		moveTaskItem->addCommand(chargeCommand);
	}
	else {
		/* //添加动作寻找霍尔开关
		HallDetCommand* hallDetCommand = new HallDetCommand();
		hallDetCommand->setParaJson(req);
		hallDetCommand->setSharedParent(moveTaskItem);
		moveTaskItem->addCommand(hallDetCommand); */
		//添加动作继电器充电
		RechargeCommand* rechargeCommand = new RechargeCommand();
		rechargeCommand->setParaJson(req);
		rechargeCommand->setSharedParent(moveTaskItem);
		moveTaskItem->addCommand(rechargeCommand);
	}
	return moveTaskItem;
}

//低电量充电
void MoveTaskManage::lowBatteryCharge()
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	//保留一条旧的动作组
	if (_rootTasks[TP_RECHARGE].getChildSize() > 0)
	{
		return;
	}
	else
	{
		g_taskMtx.lock();
		Motor *pMotor = Motor::getInstance();
		float curPos = pMotor->getCurPosition();
		//添加动作行走到充电桩
		//按距离创建到每个充电桩的任务，若执行成功，则后续任务仍执行，判断正在充电则直接退出
		Robot* pRobot = Robot::getInstance();
		if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
			for (std::list<string>::iterator iter = pRobot->m_chargingPilesName.begin(); iter != pRobot->m_chargingPilesName.end(); iter++) {
				MoveTaskItem *moveTaskItem = createChargeTaskItem(0, LOW_BATTERY_CHARGE_ITEM, LOW_BATTERY_CHARGE, *iter);
				_rootTasks[TP_RECHARGE].add(moveTaskItem);
				moveTaskItem->setParent(&_rootTasks[TP_RECHARGE]);
				printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
				LOG4CPLUS_INFO(logger, " create task: " << moveTaskItem);
			}
		}
		else {
			std::list<float> sortedPilePos;
			pRobot->getSortedChargingPilePos(curPos, sortedPilePos, pRobot->m_chargingPilesPos);
			for (std::list<float>::iterator iter = sortedPilePos.begin(); iter != sortedPilePos.end(); iter++) {
				/*if (*iter < SettingService::getInstance()->m_setting.getBeginPos() ||
					*iter > SettingService::getInstance()->m_setting.getEndPos()) {
					printf("--- MoveTaskManage::%s(), __LINE__= %d, ignore position: %f.\n",__FUNCTION__, __LINE__, *iter);
					LOG4CPLUS_INFO(logger, " ignore position: " << *iter);
					continue;
				}*/
				MoveTaskItem *moveTaskItem = createChargeTaskItem(*iter, LOW_BATTERY_CHARGE_ITEM, LOW_BATTERY_CHARGE);
				_rootTasks[TP_RECHARGE].add(moveTaskItem);
				moveTaskItem->setParent(&_rootTasks[TP_RECHARGE]);
				printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
				LOG4CPLUS_INFO(logger, " create task: " << moveTaskItem);
			}
		}
		g_taskMtx.unlock();
	}
}

//手动操作，只保留当前最新操作
void MoveTaskManage::manulCharge()
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	g_taskMtx.lock();

	//当前只能保留一条新的动作组
	clearTaskCommands(&_rootTasks[TP_MANUL]);

	Motor *pMotor = Motor::getInstance();
	float curPos = pMotor->getCurPosition();

	Robot* pRobot = Robot::getInstance();
	if (!pRobot->m_pCapabilities->isSupportBatteryCharge()) {
		printf("--- MoveTaskManage::%s(), __LINE__= %d, not supported.\n", __FUNCTION__, __LINE__);
		LOG4CPLUS_INFO(logger, " not supported.");
		goto end;
	}
	if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
		for (std::list<string>::iterator iter = pRobot->m_chargingPilesName.begin(); iter != pRobot->m_chargingPilesName.end(); iter++) {
			MoveTaskItem *moveTaskItem = createChargeTaskItem(0, MANUAL_CHARGE_ITEM, MANUAL_CHARGE, *iter);
			_rootTasks[TP_MANUL].add(moveTaskItem);
			moveTaskItem->setParent(&_rootTasks[TP_MANUL]);
			printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
			LOG4CPLUS_INFO(logger, " create task: " << moveTaskItem);
		}
	}
	else {
		std::list<float> sortedPilePos;
		pRobot->getSortedChargingPilePos(curPos, sortedPilePos, pRobot->m_chargingPilesPos);
		for (std::list<float>::iterator iter = sortedPilePos.begin(); iter != sortedPilePos.end(); iter++) {
			if (*iter <= SettingService::getInstance()->m_setting.getBeginPos() ||
				*iter >= SettingService::getInstance()->m_setting.getEndPos()) {
				printf("--- MoveTaskManage::%s(), __LINE__= %d, ignore position: %f.\n", __FUNCTION__, __LINE__, *iter);
				LOG4CPLUS_INFO(logger, " ignore position: " << *iter);
				continue;
			}
			MoveTaskItem *moveTaskItem = createChargeTaskItem(*iter, MANUAL_CHARGE_ITEM, MANUAL_CHARGE);
			_rootTasks[TP_MANUL].add(moveTaskItem);
			moveTaskItem->setParent(&_rootTasks[TP_MANUL]);
			printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
			LOG4CPLUS_INFO(logger, " create task: " << moveTaskItem);
		}
	}

end:
	g_taskMtx.unlock();
}

//创建运动控制动作组
MoveTaskItem* MoveTaskManage::createMoveCtrlTaskItem(int ctrl, float value, std::string posName)
{
	MoveTaskItem* moveTaskItem = new MoveTaskItem(MOVE_CONTROL_ITEM);
	MoveControlCommand* moveControlCommand = new MoveControlCommand();
	Json::Value req;
	req["ctrl"] = ctrl;
	req["value"] = value;
	req["posName"] = posName;
	moveControlCommand->setParaJson(req);
	moveControlCommand->setSharedParent(moveTaskItem);
	moveTaskItem->addCommand(moveControlCommand);
	moveTaskItem->initStatusPara();
	return moveTaskItem;
}

//手动运动控制 0:成功 1:失败
int MoveTaskManage::manulMoveControl(int &ctrl, float &value, std::string posName)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
	g_taskMtx.lock();

	//当前只能保留一条新的动作组
	clearTaskCommands(&_rootTasks[TP_MANUL]);

	MoveTask* moveTask = new MoveTask();
	moveTask->setParent(&_rootTasks[TP_MANUL]);
	_rootTasks[TP_MANUL].add(moveTask);

	MoveTaskItem* moveTaskItem;
	if (ctrl == Motion_Forward || ctrl == Motion_Backward || ctrl == Motion_Goto) {     //前进后退前设默认速度，行走过程打断不重复设
		moveTaskItem = new MoveTaskItem(MOVE_CONTROL_ITEM);
		SetSpeedCommand *setSpeedCommand = new SetSpeedCommand();
		Json::Value req;
		req["speed"] = SettingService::getInstance()->m_setting.getDefaultSpeed();
		setSpeedCommand->setParaJson(req);
		moveTaskItem->addCommand(setSpeedCommand);
		moveTaskItem->setParent(moveTask);
		moveTask->add(moveTaskItem);
	}

	/*     if(ctrl == Motion_Arm_Down) {     //上升前先回正云台
			moveTaskItem = new MoveTaskItem(MOVE_CONTROL_ITEM);
			PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
			Json::Value req;
			req["x_pos"] = 0;
			req["y_pos"] = 0;
			req["z_pos"] = 0;
			req["zoom"] = 0;
			req["isReturn"] = 1;
			ptzRotateCommand->setParaJson(req);
			moveTaskItem->addCommand(ptzRotateCommand);
			moveTaskItem->setParent(moveTask);
			moveTask->add(moveTaskItem);
		} */

	moveTaskItem = createMoveCtrlTaskItem(ctrl, value, posName);
	moveTaskItem->setParent(moveTask);
	moveTask->add(moveTaskItem);
	printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTask);
	LOG4CPLUS_INFO(logger, " create task: " << moveTask);
	g_taskMtx.unlock();
}

/* bool sortByPos(ViewPoint& first, ViewPoint& second)
{
	int firstPos = first.getPosition();
	int secondPos = second.getPosition();
	return (firstPos < secondPos);
} */

void selectBestViewPointRoute(std::list<ViewPoint>& pointList, int curPos)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
	Robot* pRobot = Robot::getInstance();
	if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
		pointList.sort([](ViewPoint& first, ViewPoint& second) {
			return extratNum(first.getInstanceName()) < extratNum(second.getInstanceName());
		});
		printf("MoveTaskManage:%s(), sorted PosName: ", __FUNCTION__);
		for (auto point : pointList) {
			std::cout << "point.PosName:" << point.getInstanceName();
			LOG4CPLUS_INFO(logger, " point posName: " << point.getInstanceName());
		}
		printf("\n");
	}
	else {
		pointList.sort([](ViewPoint& first, ViewPoint& second) {
			return first.getPosition() < second.getPosition();
		});
		printf("MoveTaskManage:%s(), sorted pos: ", __FUNCTION__);
		for (auto point : pointList) {
			printf("%d ", point.getPosition());
			LOG4CPLUS_INFO(logger, " point pos: " << point.getPosition());
		}
		printf("\n");

		auto iter = pointList.begin();
		while (curPos > iter->getPosition() && iter != pointList.end())
		{
			iter++;
		}
		std::list<ViewPoint> leftList(pointList.begin(), iter);
		leftList.reverse();
		std::list<ViewPoint> rightList(iter, pointList.end());

		int leftDistance = curPos - pointList.begin()->getPosition();
		int rightDistance = pointList.rbegin()->getPosition() - curPos;
		if (leftDistance < rightDistance) {
			pointList = leftList;
			pointList.splice(pointList.end(), rightList);
		}
		else {
			pointList = rightList;
			pointList.splice(pointList.end(), leftList);
		}
		printf("MoveTaskManage::%s(), best route pos: ", __FUNCTION__);
		for (auto point : pointList) {
			printf("%d ", point.getPosition());
			LOG4CPLUS_INFO(logger, " best route pos: " << point.getPosition());
		}
		printf("\n");
	}
}



//添加定时巡检任务
void MoveTaskManage::createPatroPlanTaskItem(Task& task, TaskPriority priority)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	Robot* pRobot = Robot::getInstance();
	if (pRobot->m_pCapabilities->isSupportArmMotor() && pRobot->m_pCapabilities->isSupportPtzMotor() && pRobot->m_pSettingService->m_setting.getHomeSwitch()) {
		MoveTaskManage::getInstance()->createPtzArmHomeTaskItem(priority);
	}

	g_taskMtx.lock();

	std::string sVersion = pRobot->m_pConfigServer->getRobotVersion();
	MoveTask* moveTask = new MoveTask();
	moveTask->setParent(&_rootTasks[priority]);
	_rootTasks[priority].add(moveTask);
	LOG4CPLUS_INFO(logger, "tag=regular task add type " << (int)priority << " size " << _rootTasks[priority].getChildSize());
	Json::Value req;
	int count = 1;
	MoveTaskItem* moveTaskItem = new MoveTaskItem(PATRO_PLAN_ITEM);
	moveTaskItem->setParent(moveTask);
	SetSpeedCommand *setSpeedCommand = new SetSpeedCommand();
	req["speed"] = task.getSpeed();
	setSpeedCommand->setParaJson(req);
	moveTaskItem->addCommand(setSpeedCommand);  //设置速度
	SQLOperationCommand *sqlCommand = new SQLOperationCommand();
	req["sqlNum"] = SQL_ADD_EXEC_RESULT;
	req["taskId"] = task.getTaskId();
	sqlCommand->setParaJson(req);
	sqlCommand->setSharedParent(moveTask);      //设置共享参数任务
	moveTaskItem->addCommand(sqlCommand);       //插入执行结果
/*     //根据配置添加回零动作
	if (pRobot->m_pCapabilities->isSupportArmMotor()) {
		addLiftingArmCmd(SettingService::getInstance()->m_setting.getArmLiftMoving()
						,moveTask
						,moveTaskItem,
						50); //防止homing失败
		GotoHome* gotoHome = new GotoHome();
		gotoHome->setParaJson(req);
		gotoHome->setSharedParent(moveTask);
		moveTaskItem->addCommand(gotoHome);
	} */

	moveTask->add(moveTaskItem);
	std::list<ViewPoint> viewPoints = task.getViewPoints();
	Motor *pMotor = Motor::getInstance();
	int curPos = pMotor->getCurPosition();
	selectBestViewPointRoute(viewPoints, curPos);
	int size = viewPoints.size();
	std::cout << "Number of ViewPoints: " << size << std::endl;
	//2020-10-16
	//取最后一个观测点
	std::list<ViewPoint>::iterator iterNum;
	for (std::list<ViewPoint>::iterator iter = viewPoints.begin(); iter != viewPoints.end(); ++iter)
	{
		MoveTaskItem* moveTaskItem = new MoveTaskItem(PATRO_PLAN_ITEM);
		moveTaskItem->setParent(moveTask);      //必须要指定每一级节点的parent
		moveTask->add(moveTaskItem);

		//添加行走任务
		req.clear();
		if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
			std::string posName = iter->getInstanceName();
			printf("%s(), instanceName: %s\n", __FUNCTION__, posName.c_str());
			req["pos"] = posName;
			req["rotateEnable"] = SettingService::getInstance()->m_setting.getPtzSwitch();
			T7AGotoCommand* gotoCommand = new T7AGotoCommand();
			gotoCommand->setParaJson(req);
			gotoCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(gotoCommand);
		}
		else {
			int pos = iter->getPosition();
			req["pos"] = pos;
			req["rotateEnable"] = SettingService::getInstance()->m_setting.getPtzSwitch();
			GotoCommand* gotoCommand = new GotoCommand();
			gotoCommand->setParaJson(req);
			gotoCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(gotoCommand);
		}

		//添加动作任务
		req.clear();
		req["presetNumber"] = iter->getPresetNumber();
		req["industrialCameraFocus"] = iter->getIndustrialCameraFocus();
		req["thermalImagerFocus"] = iter->getThermalImagerFocus();
		req["taskId"] = task.getTaskId();
		req["pointId"] = iter->getPointId();
		req["pointName"] = iter->getName();
		req["pddDis"] = iter->getPddDis();
		req["rotateEnable"] = SettingService::getInstance()->m_setting.getPtzSwitch();
		req["armEnable"] = SettingService::getInstance()->m_setting.getArmLiftMoving();
		req["is_pic"] = iter->getPic();
		req["is_pdd"] = iter->getPdd();
		req["is_vid"] = iter->getVideo();
		req["x_pos"] = iter->getPresetInfo().x_pos;
		req["y_pos"] = iter->getPresetInfo().y_pos;
		req["z_pos"] = iter->getPresetInfo().z_pos;
		req["zoom"] = iter->getPresetInfo().zoom;
		req["isReturn"] = 0;

		req["x1"] = iter->getX1();
		req["x2"] = iter->getX2();
		req["y1"] = iter->getY1();
		req["y2"] = iter->getY2();

		bool is_pic = iter->getPic();
		bool is_pdd = iter->getPdd();
		bool is_vid = iter->getVideo();
		bool is_arm = SettingService::getInstance()->m_setting.getArmLiftMoving();

		int pointNum = 0;
		if (std::distance(viewPoints.begin(), iter) == 0) {
			pointNum |= 1 << POINT_FIRST;
		}
		if (std::distance(iter, viewPoints.end()) == 1) {
			pointNum |= 1 << POINT_LAST;
		}
		req["pointNum"] = pointNum;
		req["armPosition"] = iter->getArmPosition();
		req["ctrl"] = Motion_Arm_MoveTo;
		req["value"] = iter->getArmPosition();

		/*         PtzArmCommand* ptzArmCommand = new PtzArmCommand();
				ptzArmCommand->setParaJson(req);
				ptzArmCommand->setSharedParent(moveTask);
				moveTaskItem->addCommand(ptzArmCommand); */

		if (pRobot->m_pCapabilities->isSupportArmMotor()) {
			MoveControlCommand* moveControlCommand = new MoveControlCommand();
			moveControlCommand->setParaJson(req);
			moveControlCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(moveControlCommand);
		}

		if (pRobot->m_pCapabilities->isSupportPtzMotor()) {
			PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
			ptzRotateCommand->setParaJson(req);
			ptzRotateCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(ptzRotateCommand);
		}


		if (is_pdd && pRobot->m_pCapabilities->isSupportPDDetect())
		{
			PddDetCommand* pddDetCommand = new PddDetCommand();
			pddDetCommand->setParaJson(req);
			pddDetCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(pddDetCommand);
		}

		if (is_pic)
		{
			TakePhotoCommand* takePhotoCommand = new TakePhotoCommand();
			takePhotoCommand->setParaJson(req);
			takePhotoCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(takePhotoCommand);
		}

		if (is_vid)
		{
			RecordVideoCommand* recordVideoCommand = new RecordVideoCommand();
			recordVideoCommand->setParaJson(req);
			recordVideoCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(recordVideoCommand);
		}

		SQLInsertCommand* sqlInsertCommand = new SQLInsertCommand();
		sqlInsertCommand->setParaJson(req);
		sqlInsertCommand->setSharedParent(moveTask);
		moveTaskItem->addCommand(sqlInsertCommand);

		if (is_pic)
		{
			ImageRecCommand* imageRecCommand = new ImageRecCommand();
			imageRecCommand->setParaJson(req);
			imageRecCommand->setSharedParent(moveTask);
			moveTaskItem->addCommand(imageRecCommand);
		}

		if (pRobot->m_pCapabilities->isSupportArmMotor() && is_arm)
		{
			if (pRobot->m_pCapabilities->isSupport2DCoordinate())
			{
				std::string posName = iter->getInstanceName();
				if (count < size) {
					std::string nextposName = (++iter)->getInstanceName();
					--iter;
					if (posName != nextposName) {
						addLiftingArmCmd(SettingService::getInstance()->m_setting.getArmLiftMoving()
							, moveTask
							, moveTaskItem);
					}
				}
			}
			else
			{
				int pos = iter->getPosition();
				if (count < size) {
					int nextpos = (++iter)->getPosition();
					--iter;
					if (pos != nextpos) {
						PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
						Json::Value req;
						req["x_pos"] = 0;
						req["y_pos"] = 0;
						req["z_pos"] = 0;
						req["zoom"] = 0;
						req["isReturn"] = 1;
						ptzRotateCommand->setParaJson(req);
						ptzRotateCommand->setSharedParent(moveTask);
						moveTaskItem->addCommand(ptzRotateCommand);
						addLiftingArmCmd(SettingService::getInstance()->m_setting.getArmLiftMoving()
							, moveTask
							, moveTaskItem);
					}
				}
			}
			count++;
		}
		/*         if(is_pic)
				{
					ImageRecCommand* imageRecCommand = new ImageRecCommand();
					imageRecCommand->setParaJson(req);
					imageRecCommand->setSharedParent(moveTask);
					moveTaskItem->addCommand(imageRecCommand);
				} */

		TakePicException *takePicException = new TakePicException();
		takePicException->setSharedParent(moveTask);
		takePicException->setParaJson(req);
		moveTaskItem->registerException(takePicException);
	}
	//2020-10-15
	iterNum = viewPoints.end();
	iterNum--;
	switch (task.getOverType())
	{
	case OVER_CHARGE:
	{
		if (!pRobot->m_pCapabilities->isSupportBatteryCharge()) {
			printf("--- MoveTaskManage::%s(), __LINE__= %d, not supported.\n", __FUNCTION__, __LINE__);
			LOG4CPLUS_INFO(logger, " not supported.");
			break;
		}
		if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
			for (std::list<string>::iterator iter = pRobot->m_chargingPilesName.begin(); iter != pRobot->m_chargingPilesName.end(); iter++) {
				MoveTaskItem *moveTaskItem = createChargeTaskItem(0, PATRO_PLAN_CHARGE_ITEM, MANUAL_CHARGE, *iter);
				moveTaskItem->setParent(moveTask);
				moveTask->add(moveTaskItem);
				printf("--- MoveTaskManage::%s(), __LINE__= %d, create OVER_CHARGE task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
				LOG4CPLUS_INFO(logger, " create OVER_CHARGE task: " << moveTaskItem);
			}
		}
		else {
			std::list<float> sortedPilePos;
			pRobot->getSortedChargingPilePos(iterNum->getPosition(), sortedPilePos, pRobot->m_chargingPilesPos);
			for (std::list<float>::iterator iter = sortedPilePos.begin(); iter != sortedPilePos.end(); iter++) {
				MoveTaskItem *moveTaskItem = createChargeTaskItem(*iter, PATRO_PLAN_CHARGE_ITEM, MANUAL_CHARGE);
				moveTaskItem->setParent(moveTask);
				moveTask->add(moveTaskItem);
				printf("--- MoveTaskManage::%s(), __LINE__= %d, create OVER_CHARGE task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
				LOG4CPLUS_INFO(logger, " create OVER_CHARGE task: " << moveTaskItem);
			}
		}
		break;
	}
	case OVER_TO_BEGINNING:
	{
		if (pRobot->m_pCapabilities->isSupport2DCoordinate()) {
			task.setOverType(OVER_STAND_STILL);
			break;
		}
		MoveTaskItem* pMoveTaskItem = new MoveTaskItem(PATRO_PLAN_ITEM);
		pMoveTaskItem->setParent(moveTask);
		req.clear();

		if (pRobot->m_pCapabilities->isSupportPtzMotor()) {
			PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
			req["x_pos"] = 0;
			req["y_pos"] = 0;
			req["z_pos"] = 0;
			req["zoom"] = 0;
			req["isReturn"] = 1;
			ptzRotateCommand->setParaJson(req);
			ptzRotateCommand->setSharedParent(moveTask);
			pMoveTaskItem->addCommand(ptzRotateCommand);
		}

		if (pRobot->m_pCapabilities->isSupportArmMotor()) {
			addLiftingArmCmd(true
				, moveTask
				, pMoveTaskItem);
		}

		req["pos"] = SettingService::getInstance()->m_setting.getBeginPos();
		req["rotateEnable"] = true;
		GotoCommand* gotoCommand = new GotoCommand();
		gotoCommand->setParaJson(req);
		gotoCommand->setSharedParent(moveTask);

		pMoveTaskItem->addCommand(gotoCommand);
		moveTask->add(pMoveTaskItem);
		printf("--- MoveTaskManage::%s(), __LINE__= %d, create OVER_TO_BEGINNING task: %p.\n", __FUNCTION__, __LINE__, gotoCommand);
		LOG4CPLUS_INFO(logger, " create OVER_TO_BEGINNING task: " << gotoCommand);
		break;
	}
	default:
		break;
	}

	printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTask);
	LOG4CPLUS_INFO(logger, " create task: " << moveTask);
	g_taskMtx.unlock();
}

//查询当前的计划任务(立即执行和定时任务)Id和观测点Id，方便上位机和web展示
int  MoveTaskManage::queryCurPlanTaskAndViewPoint(int& nTaskId, int& nViewPointId, int& nExecId, ItemType& type)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	//查询手动任务
	MoveTaskItem* moveTaskItem = getCurTaskItem();

	if (NULL != moveTaskItem)
	{
		Command *command;
		command = moveTaskItem->queryCommand(0);
		if (NULL != command && (typeid(*command) == typeid(GotoCommand) || typeid(*command) == typeid(T7AGotoCommand)))
		{
			Json::Value json = command->getParaJson();
			nTaskId = json["taskId"].asInt();
			nViewPointId = json["pointId"].asInt();
			Json::Value* sharedJson = command->getSharedParaJson();
			if (sharedJson == NULL) {
				printf("--- MoveTaskManage::%s(), __LINE__= %d, moveTaskItem: %p, cur taskId: %d, viewPointId: %d, shared json is null.\n", __FUNCTION__, __LINE__, moveTaskItem, nTaskId, nViewPointId);
				LOG4CPLUS_INFO(logger, " moveTaskItem: " << moveTaskItem << ", cur taskId: " << nTaskId << ", viewPointId: " << nViewPointId << ", shared json is null");
				return -1;
			}
			nExecId = (*sharedJson)[JSON_EXEC_ID].asInt();
			printf("--- MoveTaskManage::%s(), __LINE__= %d, moveTaskItem: %p, cur taskId: %d, viewPointId: %d, execId: %d.\n", __FUNCTION__, __LINE__, moveTaskItem, nTaskId, nViewPointId, nExecId);
			LOG4CPLUS_INFO(logger, " moveTaskItem: " << moveTaskItem << ", cur taskId: " << nTaskId << ", viewPointId: " << nViewPointId << ", execId: " << nExecId);
		}
		else {
			nViewPointId = -1;
		}
		if (videoflag)
		{
			type = VIDEO_PLAN_ITEM;
		}
		else {
			type = moveTaskItem->m_itemType;
		}
	}
	else {
		nViewPointId = -1;
		nTaskId = -1;
		nExecId = -1;
		type = NO_ITEM;
	}
	return 0;

	/* //查询手动任务是否是立即执行计划任务
	bool existImPlanName = false;
	if(NULL != moveTaskItem)
	{
		Command *command;
		command = moveTaskItem->queryCommand(1);
		if(NULL != command && typeid(*command) == typeid(TakePicCommand))
		{
			existImPlanName = true;
		}
	}

	查询定时任务
	if(!existImPlanName) 无立即执行任务
	{
		moveTaskItem =(MoveTaskItem *) _rootTasks[TP_REGULAR].findLeftMostChild();
	}

	if(NULL != moveTaskItem)
	{
		Command *command;
		command = moveTaskItem->queryCommand(1);
		assert(NULL != command);
		Json::Value json = command->getParaJson();
		nTaskId = json["taskId"].asInt();
		nViewPointId = json["pointId"].asInt();
		return 0;
	}
	return -1; */
}


//添加RFID动作组
void MoveTaskManage::createRFIDTaskItem(int rfidNum)
{
	// g_taskMtx.lock();

	// RFID rfid;
	// MotorDriver *motorDriver = MotorDriver::getInstance();
	// if(0 == RFIDService::queryRFIDByRfidNum(rfidNum, rfid))//查询成果
	// {
	// 	//判断当前机器的运动方向
	//     if(GO_AHEAD == motorDriver->getCurStatus())
	// 	{
	//         Command *command = generateCommandByActionId(rfid.getGoActionId(), rfid.getGoActionParam());
	// 		if(NULL !=command)
	// 		{
	// 			//当前只能保留一条新的动作组
	//             clearTaskCommands(&_rootTasks[TP_RFID]);

	// 			MoveTaskItem* moveTaskItem = new MoveTaskItem();
	// 			moveTaskItem->initStatusPara();
	//             moveTaskItem->addCommand(command);
	// 			_rootTasks[TP_RFID].add(moveTaskItem);
	//             moveTaskItem->setParent(&_rootTasks[TP_RFID]);
	// 		}
	// 	}
	//     else if(GO_BACK == motorDriver->getCurStatus())
	// 	{
	//         Command *command = generateCommandByActionId(rfid.getBackActionId(), rfid.getBackActionParam());
	// 		if(NULL !=command)
	// 		{
	// 			//当前只能保留一条新的动作组
	//             clearTaskCommands(&_rootTasks[TP_RFID]);

	// 			MoveTaskItem* moveTaskItem = new MoveTaskItem();
	// 			moveTaskItem->initStatusPara();
	//             moveTaskItem->addCommand(command);
	// 			_rootTasks[TP_RFID].add(moveTaskItem);
	//             moveTaskItem->setParent(&_rootTasks[TP_RFID]);
	// 		}		
	// 	}

	// }
	// g_taskMtx.unlock();
}

//添加定点任务动作组
void MoveTaskManage::createPositionPlanTaskItem(PositionPlan& pos, MoveState direct)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	g_taskMtx.lock();
	Command *command = NULL;
	if (AHEAD_STATE == direct) {
		command = generateCommandByActionId(pos.getGoActionId(), pos.getGoActionParam());
	}
	else if (BACK_STATE == direct) {
		command = generateCommandByActionId(pos.getBackActionId(), pos.getBackActionParam());
	}
	if (NULL != command) {
		//当前只能保留一条新的动作组
		clearTaskCommands(&_rootTasks[TP_PLAN]);
		MoveTaskItem* moveTaskItem = new MoveTaskItem(POSITION_PLAN_ITEM);
		command->setSharedParent(moveTaskItem);
		moveTaskItem->initStatusPara();
		moveTaskItem->addCommand(command);
		_rootTasks[TP_PLAN].add(moveTaskItem);
		moveTaskItem->setParent(&_rootTasks[TP_PLAN]);
		printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTaskItem);
		LOG4CPLUS_INFO(logger, " create task: " << moveTaskItem);
	}
	g_taskMtx.unlock();
}

//根据动作Id,生成Command
Command* MoveTaskManage::generateCommandByActionId(int actionId, std::string actionParam)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);

	Command* command = NULL;
	Json::Reader reader;
	Json::Value req;

	if (!reader.parse(actionParam, req, false))
	{
		printf("--- ConfigServer::parseJSON -1 \n");
		LOG4CPLUS_INFO(logger, " ConfigServer::parseJSON -1 ");
		return command;
	}
	switch (actionId)
	{
	case AT_SET_SPEED:
	{
		printf("--- generating command: SET_SPEED \n");
		LOG4CPLUS_INFO(logger, " generating command: SET_SPEED ");

		SetSpeedCommand* setSpeedCommand = new SetSpeedCommand();
		setSpeedCommand->setParaJson(req);
		return setSpeedCommand;
	}
	case AT_RECOVER_SPEED:
	{
		printf("--- generating command: RECOVER_SPEED \n");
		LOG4CPLUS_INFO(logger, " generating command: RECOVER_SPEED ");
		RecoverSpeedCommand* recoverSpeedCommand = new RecoverSpeedCommand();
		recoverSpeedCommand->setParaJson(req);
		return recoverSpeedCommand;
	}
	case AT_MOVE_CONTROL:
	{
		printf("--- generating command: MOVE_CONTROL \n");
		LOG4CPLUS_INFO(logger, " generating command: MOVE_CONTROL ");
		MoveControlCommand* moveControlCommand = new MoveControlCommand();
		moveControlCommand->setParaJson(req);
		return moveControlCommand;
	}
	case AT_SET_DRIVE_MODE:
	{
		printf("--- generating command: SET_DRIVE_MODE \n");
		LOG4CPLUS_INFO(logger, " generating command: SET_DRIVE_MODE ");
		DriveModeCommand* driveModeCommand = new DriveModeCommand();
		driveModeCommand->setParaJson(req);
		return driveModeCommand;
	}
	case AT_DOOR_SWITCH:
	{
		printf("--- generating command: DOOR_SWITCH \n");
		LOG4CPLUS_INFO(logger, " generating command: DOOR_SWITCH ");
		DoorSwitchCommand* doorSwitchCommand = new DoorSwitchCommand();
		doorSwitchCommand->setParaJson(req);
		return doorSwitchCommand;
	}
	case AT_US_SWITCH:
	{
		printf("--- generating command: US_SWITCH \n");
		LOG4CPLUS_INFO(logger, " generating command: US_SWITCH ");
		USSwitchCommand* uSSwitchCommand = new USSwitchCommand();
		uSSwitchCommand->setParaJson(req);
		return uSSwitchCommand;
	}
	case AT_INFRARED_SWITCH:
	{
		printf("--- generating command: INFRARED_SWITCH \n");
		LOG4CPLUS_INFO(logger, " generating command: INFRARED_SWITCH ");
		InfraredSwitchCommand* infraredSwitchCommand = new InfraredSwitchCommand();
		infraredSwitchCommand->setParaJson(req);
		return infraredSwitchCommand;
	}
	case AT_LIFT_LOCK:
	{
		printf("--- generating command: LIFT_LOCK \n");
		LOG4CPLUS_INFO(logger, " generating command: LIFT_LOCK ");

		LiftLockCommand* liftLockCommand = new LiftLockCommand();
		liftLockCommand->setParaJson(req);
		return liftLockCommand;
	}
	case AT_CHECK_FD:
	{
		printf("--- generating command: CHECK_FD \n");
		LOG4CPLUS_INFO(logger, " generating command: CHECK_FD ");

		CheckFDCommand* checkFDCommand = new CheckFDCommand();
		checkFDCommand->setParaJson(req);
		return checkFDCommand;
	}
	case AT_US_SET_THRESHOLD:
	{
		printf("--- generating command: US_SET_THRESHOLD \n");
		LOG4CPLUS_INFO(logger, " generating command: US_SET_THRESHOLD ");
		USSetThresholdCommand* setThresholdCommand = new USSetThresholdCommand();
		setThresholdCommand->setParaJson(req);
		return setThresholdCommand;
	}
	case AT_SET_MAX_CURRENT:
	{
		printf("--- generating command: AT_SET_MAX_CURRENT \n");
		LOG4CPLUS_INFO(logger, " generating command: AT_SET_MAX_CURRENT ");
		SetMaxCurrentCommand* setCurrentCommand = new SetMaxCurrentCommand();
		setCurrentCommand->setParaJson(req);
		return setCurrentCommand;
	}
	case AT_LIFTARM_CONTROL:
	{
		printf("--- generating command: AT_LIFTARM_CONTROL \n");
		LOG4CPLUS_INFO(logger, " generating command:AT_LIFTARM_CONTORL ");
		LiftArmCommand* liftArmCommand = new LiftArmCommand();
		liftArmCommand->setParaJson(req);
		return liftArmCommand;
	}

	default:
	{
		return command;
	}
	}
}

void MoveTaskManage::clearManualTaskCommands()
{
	g_taskMtx.lock();

	clearTaskCommands(&_rootTasks[TP_MANUL]);

	g_taskMtx.unlock();
}

void MoveTaskManage::clearChargeTaskCommands()
{
	g_taskMtx.lock();

	clearTaskCommands(&_rootTasks[TP_RECHARGE]);

	g_taskMtx.unlock();
}

//递归清除任务所有的动作组,item由process统一删除
void MoveTaskManage::clearTaskCommands(MoveTaskComponent* moveTask)
{
	if (moveTask == NULL || moveTask->findLeftMostChild() == NULL) { return; }   //没有Item节点,返回

	if (moveTask->findLeftMostChild() == moveTask) {         //是Item节点,清除commands,递归结束
		MoveTaskItem* moveTaskItem = dynamic_cast<MoveTaskItem*>(moveTask);
		moveTaskItem->clearCommands();
		return;
	}
	for (int i = 0; i < moveTask->getChildSize(); i++) {     //不是Item节点,则递归删除
		clearTaskCommands(moveTask->getChild(i));
	}
}

void MoveTaskManage::clearTaskCommandsExceptPatroPlan(MoveTaskComponent* moveTask)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
	if (moveTask == NULL || moveTask->findLeftMostChild() == NULL) { return; }   //没有Item节点,返回

	if (moveTask->findLeftMostChild() == moveTask) {         //是Item节点,清除commands,递归结束
		MoveTaskItem* moveTaskItem = dynamic_cast<MoveTaskItem*>(moveTask);
		if (moveTaskItem->m_itemType != PATRO_PLAN_ITEM &&
			moveTaskItem->m_itemType != PATRO_PLAN_CHARGE_ITEM) {
			moveTaskItem->clearCommands();
		}
		else {
			printf("MoveTaskManage::%s(), __LINE__= %d, ignore taskItem: %p\n", __FUNCTION__, __LINE__, moveTaskItem);
			LOG4CPLUS_INFO(logger, " ignore taskItem: " << moveTaskItem);
		}
		return;
	}
	for (int i = 0; i < moveTask->getChildSize(); i++) {     //不是Item节点,则递归删除
		clearTaskCommandsExceptPatroPlan(moveTask->getChild(i));
	}
}

void MoveTaskManage::createPtzArmHomeTaskItem(TaskPriority priority)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
	g_taskMtx.lock();

	//当前只能保留一条新的动作组
	clearTaskCommands(&_rootTasks[priority]);
	MoveTask* moveTask = new MoveTask();
	moveTask->setParent(&_rootTasks[priority]);
	_rootTasks[priority].add(moveTask);

	MoveTaskItem* moveTaskItem = new MoveTaskItem(POWER_ON_PLAN_ITEM);

	//添加收机械臂动作
	addLiftingArmCmd(true
		, moveTask
		, moveTaskItem
		, 150);

	Json::Value req;
	req["x_pos"] = 0;
	req["y_pos"] = 0;
	req["z_pos"] = 0;
	req["zoom"] = 0;
	req["pddDis"] = 0;
	req["isReturn"] = 1;

	PddDetCommand* pddDetCommand = new PddDetCommand();
	pddDetCommand->setParaJson(req);
	pddDetCommand->setSharedParent(moveTask);
	moveTaskItem->addCommand(pddDetCommand);

	PtzRotateCommand* ptzRotateCommand = new PtzRotateCommand();
	ptzRotateCommand->setParaJson(req);
	ptzRotateCommand->setSharedParent(moveTask);
	moveTaskItem->addCommand(ptzRotateCommand);

	GotoHome* gotoHome = new GotoHome();
	gotoHome->setParaJson(req);
	gotoHome->setSharedParent(moveTask);
	moveTaskItem->addCommand(gotoHome);

	moveTaskItem->setParent(moveTask);
	moveTask->add(moveTaskItem);

	printf("--- MoveTaskManage::%s(), __LINE__= %d, create task: %p.\n", __FUNCTION__, __LINE__, moveTask);
	LOG4CPLUS_INFO(logger, " create task: " << moveTask);
	g_taskMtx.unlock();
}

void MoveTaskManage::setVideoflag(int nFlag)
{
	videoflag = nFlag;
}
