//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : HallDetCommand.cpp
//  @ Date : 2019-06-27
//  @ Author : ShunWang
//
//


#include "HallDetCommand.h"
#include "RechargeCommand.h"
#include "Transaction/SettingService.h"
#include "Robot.h"
#include <math.h>
#include <stdlib.h>
#include "Driver/MyLog4CXX.h"

const std::string LOG_TAG("root.HallDetCommand::");

#define DETECT_RANGE 500   //mm
#define ERROR_RANGE 250
#define SLOW_DOWN_SPEED 30  //mm/s

int HallDetCommand::exec()
{
    auto logger = initLogger(LOG_TAG + std::string(__FUNCTION__));
	Motor *pMotor = Motor::getInstance();
	HallDriver *hallDriver = HallDriver::getInstance();
    int nRet = 0;
    float fDestPos = _paraJson["destPos"].asFloat();
    Json::Value *sharedJson = getSharedParaJson();
    static int sign = 1;
	if (_exeRet != ST_SUCCESS && _exeRet != ST_FAIL)
	{
	    switch(_exeStatus)
		{
            case HALLDET_ST_WAIT:
            {
                if(sharedJson != NULL) {
                    (*sharedJson)[JSON_EXEC_RESULT] = ST_FAIL;
                    setSharedParaJson(sharedJson);
                    printf("HallDetCommand::%s(),ret: %d\n", __FUNCTION__, (*sharedJson)[JSON_EXEC_RESULT].asInt());
                    LOG4CPLUS_INFO(logger, (*sharedJson)[JSON_EXEC_RESULT].asInt());
                }
                Robot* pRobot = Robot::getInstance(); 
                float current = pRobot->m_pBatteryDriver->getCurrent();

                if(current > 0.5) {        //在充电，不重新移动
                    printf("HallDetCommand::exec(), already in charging.\n");
                    LOG4CPLUS_INFO(logger, " already in charging. ");
					setExeRet(ST_SUCCESS); 
                    break;
                }

                //会导致首次充电不成功，不会前往第二个充电桩
				/* if(true == hallDriver->getHall()) { //检测到霍尔开关 
                    printf("HallDetCommand::%s(), hall detected!\n", __FUNCTION__);
                    LOG4CPLUS_INFO(logger, " hall detected! ");
					nRet = pMotor->emergeStop();
                    printf("HallDetCommand::%s(), emergency stop, nRet: %d\n", __FUNCTION__, nRet);
                    LOG4CPLUS_INFO(logger, " emergency stop, nRet: " << nRet);
					setExeRet(ST_SUCCESS); 
                    if(sharedJson != NULL) {
                        (*sharedJson)[JSON_EXEC_RESULT] = ST_SUCCESS;
                        setSharedParaJson(sharedJson);
                        printf("HallDetCommand::%s(), hall detected!\n", __FUNCTION__);
                        LOG4CPLUS_INFO(logger, " hall detected! ");
                    }
                    break;
				} */

                Motor *pMotor = Motor::getInstance();
		        // pMotor->armMoveTo(0);
                float fCurPos = pMotor->getCurPosition()*1.0;

                if((fCurPos - fDestPos) > 0) {
                    sign = -1;
                }
                else {
                    sign = 1;
                }
                _exeStatus = HALLDET_ST_BACK500;
                _tryCnt = 0;
                clearTimer();

                break;
            }
            case HALLDET_ST_BACK500:
            {
                if(0 != sleeepWaitTimeOut(10)) { break; }
                nRet = pMotor->goTo(fDestPos-sign*DETECT_RANGE);
                printf("HallDetCommand::%s(), go to %f, nRet: %d\n", __FUNCTION__, fDestPos-sign*DETECT_RANGE, nRet);
                LOG4CPLUS_INFO(logger, " go to "<< fDestPos-sign*DETECT_RANGE << ", nRet: " << nRet);
				if(nRet == RET_SUCCESS) {
					_tryCnt = 0;
                    clearTimer();
	                _exeStatus = HALLDET_ST_BACK500_WAIT;
				}
				else {
	                if(_tryCnt < 5) {
                        printf("HallDetCommand::%s(), go to %f failed, try again!\n", __FUNCTION__, fDestPos-sign*DETECT_RANGE);
                        LOG4CPLUS_INFO(logger, " go to "<< fDestPos-sign*DETECT_RANGE << " failed, try again!");

                        _tryCnt++;
					}
					else {
                        printf("HallDetCommand::%s(), go to %f failed, exit!\n", __FUNCTION__, fDestPos-sign*DETECT_RANGE);
                        LOG4CPLUS_INFO(logger, " go to "<< fDestPos-sign*DETECT_RANGE << " failed, exit!");
						setExeRet(ST_FAIL); 
					}
				}
				break;
            }
            case HALLDET_ST_BACK500_WAIT:
            {
                if(0 != sleeepWaitTimeOut(10)) { break; }
                if(STOP_STATE == pMotor->getCurStatus()) {
                    float fPosition = pMotor->getCurPosition();
                    if(fabs(fPosition - (fDestPos-sign*DETECT_RANGE)) < ERROR_RANGE) { //只有电机停止运动并到达位置后才会结束检测，进入下一阶段
                        _tryCnt = 0;
                        clearTimer();
                        _exeStatus = HALLDET_ST_SLOW_DOWN;
                    }
                    else {
                        pMotor->goTo(fDestPos-sign*DETECT_RANGE);
                    }
                    _tryCnt++;
                    if(_tryCnt > 5) {
                        if (fPosition >= fDestPos-sign*DETECT_RANGE && fPosition <= fDestPos) {
                            _tryCnt = 0;
                            clearTimer();
                            _exeStatus = HALLDET_ST_SLOW_DOWN;
                            printf("HallDetCommand::%s(), line: %d, detected stop exception, next step!\n", __FUNCTION__, __LINE__);
                            LOG4CPLUS_INFO(logger, " detected stop exception, next step! ");
                        }
                        else {
                            printf("HallDetCommand::%s(), line: %d, no move, exit!\n", __FUNCTION__, __LINE__);
                            LOG4CPLUS_INFO(logger, " no move, exit! ");
                            setExeRet(ST_FAIL); 
                        }
                    }
                }		
                break;
            }
            case HALLDET_ST_SLOW_DOWN:
            {
                if(0 != sleeepWaitTimeOut(1)) { break; }
                nRet = pMotor->setSpeed(SLOW_DOWN_SPEED);
                printf("HallDetCommand::%s(), set speed: %d, nRet: %d\n", __FUNCTION__, SLOW_DOWN_SPEED, nRet);
                LOG4CPLUS_INFO(logger, " set speed: "<< SLOW_DOWN_SPEED << ", nRet: " << nRet);
				if(nRet == RET_SUCCESS) { 
					_tryCnt = 0;
                    clearTimer();
                    _exeStatus = HALLDET_ST_GO500;
				}
				else {
	                if(_tryCnt < 5) {
                        printf("HallDetCommand::%s(), speed: %d, slow down failed, try again!\n", __FUNCTION__, SLOW_DOWN_SPEED);
                        LOG4CPLUS_INFO(logger, " speed: "<< SLOW_DOWN_SPEED << ",  slow down failed, try again! ");
                        _tryCnt++;
					}
					else {
                        printf("HallDetCommand::%s(), speed: %d, slow down failed, exit!\n", __FUNCTION__, SLOW_DOWN_SPEED);
                        LOG4CPLUS_INFO(logger, " speed: "<< SLOW_DOWN_SPEED << ",  slow down failed, exit! ");
						setExeRet(ST_FAIL); 
					}
				}
                break;
            }
			case HALLDET_ST_GO500:
			{
                if(0 != sleeepWaitTimeOut(10)) { break; }
                nRet = pMotor->goTo(fDestPos+sign*DETECT_RANGE);
                printf("HallDetCommand::%s(), go to %f, nRet: %d\n", __FUNCTION__, fDestPos+sign*DETECT_RANGE, nRet);
                LOG4CPLUS_INFO(logger, " go to "<< fDestPos+sign*DETECT_RANGE << ", nRet: " << nRet);
	            if(nRet == RET_SUCCESS) {
					_tryCnt = 0;
					clearTimer();
	                _exeStatus = HALLDET_ST_GO500_WAIT;
				}
				else {
	                if(_tryCnt < 5) {
                        printf("HallDetCommand::%s(), go to %f failed, try again!\n", __FUNCTION__, fDestPos+DETECT_RANGE);
                        LOG4CPLUS_INFO(logger, " go to "<< fDestPos+DETECT_RANGE << " failed, try again!");

                        _tryCnt++;
					}
					else {
                        printf("HallDetCommand::%s(), go to %f failed, exit!\n", __FUNCTION__, fDestPos+sign*DETECT_RANGE);
                        LOG4CPLUS_INFO(logger, " go to "<< fDestPos+sign*DETECT_RANGE << " failed, exit!");

                        _tryCnt = 0;
                        clearTimer();
                        _exeStatus = HALLDET_ST_SPEED_UP;
					}
				}
				break;
			}
			case HALLDET_ST_GO500_WAIT:
			{
				if(true == hallDriver->getHall()) {
					pMotor->emergencyStop();
                    _tryCnt = 0;
					clearTimer();
                    _exeStatus = HALLDET_ST_SPEED_UP;
                    if(sharedJson != NULL) {
                        (*sharedJson)[JSON_EXEC_RESULT] = ST_SUCCESS;
                        setSharedParaJson(sharedJson);
                        printf("HallDetCommand::%s(), hall detected!\n", __FUNCTION__);
                        LOG4CPLUS_INFO(logger, " hall detected! ");
                    }
				}
				else
				{
                    if(0 != sleeepWaitTimeOut(10)) { break; }
                    if(STOP_STATE == pMotor->getCurStatus()) {
                        _tryCnt++;
                        if(_tryCnt > 5) {
                            printf("HallDetCommand::%s(), line: %d, not detected, exit!\n", __FUNCTION__, __LINE__);
                            LOG4CPLUS_INFO(logger, " not detected, exit! ");

                            _tryCnt = 0;
                            clearTimer();
                            _exeStatus = HALLDET_ST_SPEED_UP;
                        }
                    }
                }
				break;	
			}
            case HALLDET_ST_SPEED_UP:
            {
                if(0 != sleeepWaitTimeOut(1)) { break; }
                float defaultSpeed = SettingService::getInstance()->m_setting.getDefaultSpeed();
                nRet = pMotor->setSpeed(defaultSpeed);
                printf("HallDetCommand::%s(), set speed: %f, nRet: %d\n", __FUNCTION__, defaultSpeed, nRet);
                LOG4CPLUS_INFO(logger, " set speed: "<< defaultSpeed << ", nRet: " << nRet);
				if(nRet == RET_SUCCESS) {
					_tryCnt = 0;
                    clearTimer();
                    setExeRet(ST_SUCCESS); 
				}
				else {
	                if(_tryCnt < 5) {
                        printf("HallDetCommand::%s(), speed: %f, set speed failed, try again!\n", __FUNCTION__, defaultSpeed);
                        LOG4CPLUS_INFO(logger, " speed: "<< defaultSpeed << ",  set speed failed, try again! ");

                        _tryCnt++;
					}
					else {
                        printf("HallDetCommand::%s(), speed: %f, set speed failed, exit!\n", __FUNCTION__, defaultSpeed);
                        LOG4CPLUS_INFO(logger, " speed: "<< defaultSpeed << ",  set speed failed, exit! ");

						setExeRet(ST_FAIL); 
					}
				}
                break;
            }
			default:
			{
				break;
			}
		}
	}

	return _exeRet;
}

