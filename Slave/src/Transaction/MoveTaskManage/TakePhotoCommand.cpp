//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : TakePhotoCommand.cpp
//  @ Date : 2019-07-02
//  @ Author : ShunWang
//
//

#include "TakePhotoCommand.h"
#include "Transaction/Robot.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "Common/HttpPost/CHttpPost.hpp"
#include "Poco/Net/HTTPResponse.h"
#include "Poco/StreamCopier.h"
#include <iostream>
#include "Common/FtpClient/CFtpClient.h"
#include "Transaction/ConfigServer.h"
#include "Common/HIKClient/HIKClient.h"
#include "Common/IRAYClient/IRAYClient.h"
#include <vector>
#include <cmath>

const std::string LOG_TAG("root.TakePhotoCommand::");
extern ViewPointInfo patrolViewPointInfo;
std::string uploadCameraPic;

int TakePhotoCommand::exec()
{
    std::string logname = LOG_TAG + std::string(__FUNCTION__);
    auto logger = initLogger(logname);

    patrolViewPointInfo.nExecRes = EXEC_SUCCESS;

	//解析JSON参数
    int industrialCameraFocus = _paraJson["industrialCameraFocus"].asInt();
	int thermalImagerFocus = _paraJson["thermalImagerFocus"].asInt();
	int taskId = _paraJson["taskId"].asInt();
	int pointId = _paraJson["pointId"].asInt();
    std::string pointName = _paraJson["pointName"].asString();

    float x1 = _paraJson["x1"].asFloat();
	float y1 = _paraJson["y1"].asFloat();
	float x2 = _paraJson["x2"].asFloat();
	float y2 = _paraJson["y2"].asFloat();

    Robot *pRobot = Robot::getInstance();
    HIKClient *pClient = HIKClient::getInstance();
    IRAYClient *pIRAYClient = IRAYClient::getInstance();
    Json::Value *sharedJson = getSharedParaJson();

    if(sharedJson == NULL) {
        printf("TakePhotoCommand::%s(), can't get json value!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " can't get json value! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }

    if ((*sharedJson)[JSON_EXEC_RESULT].asInt() != ST_SUCCESS) {
        printf("TakePhotoCommand::%s(), last command execute failed, exit!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " last command execute failed, exit! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }

    int execId = (*sharedJson)[JSON_EXEC_ID].asInt();
    pRobot->m_nPhotoIndex = 0;

    if(execId < 0) {
        setExeRet(ST_FAIL);
        printf("TakePhotoCommand::%s(), __LINE__ = %d: no exec id, return!\n", __FUNCTION__, __LINE__);
        LOG4CPLUS_ERROR(logger, " no exec id, return! ");
    }
	setExeRet(ST_GOING);
    
    switch(_exeStatus)
	{
		case TAKEPHO_ST_BEGAIN:
		{
            //设置本地和服务器上传路径
            //品牌_数据源类型_巡检点名称_文件类型_时间戳.jpg
            //数据源类型：wc（广角）、ic（红外）、dc（深度）
            //文件类型：pic（图片）、data（数据文件）、video（视频文件）
			std::string camFileName, thFileName, tempFileName;
            time_t tim;
            time(&tim);
            struct tm* tTime = localtime(&tim);
            char timestamp[20] = "";
            char server_timestamp[20] = "";
            snprintf(timestamp, sizeof(timestamp), "%04d%02d%02d%02d%02d%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, tTime->tm_hour, tTime->tm_min, tTime->tm_sec);
            snprintf(server_timestamp, sizeof(server_timestamp), "%04d-%02d-%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday);

			camFileName += "tetraelc_wc_" + pointName + "_pic_" + timestamp + ".jpg";
            thFileName +=  "tetraelc_ic_" + pointName + "_pic_" + timestamp + ".jpg";
            tempFileName += "tetraelc_ic_" + pointName + "_data_" + timestamp;

            std::string uploadCamera = pRobot->m_pSettingService->m_setting.getPicturePath() + std::to_string(pRobot->m_nRobotID) 
            + "/" + server_timestamp + "/" + "ViewPiontCameraPicture";
			std::string uploadThermel = pRobot->m_pSettingService->m_setting.getPicturePath() + std::to_string(pRobot->m_nRobotID)
            + "/" + server_timestamp + "/" + "ViewPiontCameraPicture";
			uploadCameraPic = uploadCamera + "/" + camFileName;
			std::string uploadThermelPic = uploadThermel + "/" + thFileName;

            //本地保存路径不存在，则新建
            if(access(uploadCamera.c_str(), F_OK) != 0) {
                char cmd[1024] = "";
                snprintf(cmd, sizeof(cmd), "mkdir -p %s", uploadCamera.c_str());
                system(cmd);
                printf("TakePhotoCommand::%s(), %s\n", __FUNCTION__, cmd);
                LOG4CPLUS_INFO(logger, LOG4CPLUS_C_STR_TO_TSTRING(cmd));
            }

            //拍照
            int nCameraRet = -1, nThermalRet = -1, nTempRet = -1, nTry;
            nTry = 0;
            while (nCameraRet != 0 && nTry < 3) {
                nTry++;
                char cmd[1024] = "";
                if(pRobot->m_pConfigServer->getRobotVersion() == "t3e") {
                    nCameraRet = pRobot->m_pIndustrialCamera->takePicture(const_cast<char*>(uploadCameraPic.c_str()));
                }else {
                    snprintf(cmd, sizeof(cmd), "ffmpeg -y -i rtsp://%s:%s@%s:554/h264/ch1/main/avstream -f image2 -t 0.5 %s", pRobot->m_pSettingService->m_setting.getCameraUserName().c_str(),
                    pRobot->m_pSettingService->m_setting.getCameraPassword().c_str(), pRobot->m_pSettingService->m_setting.getIndustrialCameraIp().c_str(), uploadCameraPic.c_str());
                    nCameraRet = 0;
                    system(cmd);
                }
                printf("TakePhotoCommand::%s(), local cameraPic path: %s, nRet: %d\n", __FUNCTION__, uploadCameraPic.c_str(), nCameraRet);
                LOG4CPLUS_INFO(logger, " local cameraPic path: "<< uploadCameraPic << ", nRet: " << nCameraRet);
            }
            
            nTry = 0;
            while (nThermalRet != 0 && nTry < 3) {
                nTry++;
                char cmd[1024] = "";
                snprintf(cmd, 1024, "ffmpeg -y -i rtsp://%s:%s@%s:554/stream0 -f image2 -t 0.5 %s", "888888", "888888", pRobot->m_pSettingService->m_setting.getThermalImagerIp().c_str(), uploadThermelPic.c_str());
                nThermalRet = 0;
                system(cmd);
                printf("TakePhotoCommand::%s(), local thermalPic path: %s, nRet: %d\n", __FUNCTION__, uploadThermelPic.c_str(), nThermalRet);
                LOG4CPLUS_INFO(logger, " local thermalPic path: "<< uploadThermelPic << ", nRet: "<< nThermalRet);
            }

			//插入任务运行日志记录
            patrolViewPointInfo.nTaskId = taskId;
            patrolViewPointInfo.nExecId = execId;
			patrolViewPointInfo.nViewPointId = pointId;

			patrolViewPointInfo.fTemperature = pRobot->m_pSensorBoardEx->getEnvInfo().fTemperature;
			patrolViewPointInfo.fHumidity = pRobot->m_pSensorBoardEx->getEnvInfo().fHumidity;
			patrolViewPointInfo.fCombustible = pRobot->m_pSensorBoardEx->getGasInfo().fCH4;
			patrolViewPointInfo.fCO = pRobot->m_pSensorBoardEx->getGasInfo().fCO;
			patrolViewPointInfo.fH2S = pRobot->m_pSensorBoardEx->getGasInfo().fSO2;
			patrolViewPointInfo.fO2 = pRobot->m_pSensorBoardEx->getGasInfo().fO2;

			patrolViewPointInfo.fThermelMaxTemp = 0.0;
			patrolViewPointInfo.strCameraPhotoPath = uploadCameraPic.c_str();
			patrolViewPointInfo.strThermelPhotoPath = uploadThermelPic.c_str();
            patrolViewPointInfo.nposition = Motor::getInstance()->getCurPosition();

            pRobot->m_nPhotoIndex++;
/*             snprintf(cmd, 1024, "rm -r %s", pRobot->m_sPhotoRootPathDate.c_str());
            system(cmd);
            printf("TakePhotoCommand::%s(), %s\n", __FUNCTION__, cmd);
            LOG4CPLUS_INFO(logger, LOG4CPLUS_C_STR_TO_TSTRING(cmd)); */
            _exeStatus = TAKEPHO_ST_FINSIH;
			break;
		}
        case TAKEPHO_ST_FINSIH:
		{
            std::vector<float> corners = {x1, y1, x2, y2};
            if((abs(corners[0]) < 0.01 && abs(corners[1]) < 0.01 && abs(corners[2]) < 0.01 && abs(corners[3]) < 0.01) || 
               (abs(corners[0] - corners[2]) < 0.01) || (abs(corners[1] - corners[3]) < 0.01)) {
                patrolViewPointInfo.fThermelMaxTemp = 0.0;
                setExeRet(ST_SUCCESS);
                break;
            }
            else {
                pIRAYClient->get_local_temp(corners);
                patrolViewPointInfo.fThermelMaxTemp = pIRAYClient->getMaxTemp();
                setExeRet(ST_SUCCESS);
                break;
            }

/*             if(0 != pClient->getMinMaxTemp())
            {
                printf( "%s Update temp info failed! \n", __FUNCTION__);
                LOG4CPLUS_INFO(logger, "Update temp info failed!");
            } */
            setExeRet(ST_SUCCESS);
			break;
		}
		default:
		{
            setExeRet(ST_FAIL);
			break;
		}
	}
    return _exeRet;
}
