//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : TakePicCommand.cpp
//  @ Date : 2019-07-02
//  @ Author : ShunWang
//
//


#include "TakePicCommand.h"
#include "Transaction/Robot.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "Common/HttpPost/CHttpPost.hpp"
#include "Poco/Net/HTTPResponse.h"
#include "Poco/StreamCopier.h"
#include <iostream>
#include "Driver/MyLog4CXX.h"
#include "Driver/PDDMotorDriver.h"
#include "Common/FtpClient/CFtpClient.h"
#include "Transaction/ConfigServer.h"
#include "Common/HIKClient/HIKClient.h"

const std::string LOG_TAG("root.TakePicCommand::");

int TakePicCommand::exec()
{
    std::string logname = LOG_TAG + std::string(__FUNCTION__);
    auto logger = initLogger(logname);

    static ViewPointInfo viewPointInfo;
    static int preVPsetNum = 0;
    static int prearmPos = 0;
    static int transId = 0;
    static int time_cnt = 0;
    viewPointInfo.nExecRes = EXEC_SUCCESS;
    uint16_t stateBite;
	//解析JSON参数
	int presetNumber = _paraJson["presetNumber"].asInt();
    int industrialCameraFocus = _paraJson["industrialCameraFocus"].asInt();
	int thermalImagerFocus = _paraJson["thermalImagerFocus"].asInt();
	int taskId = _paraJson["taskId"].asInt();
	int pointId = _paraJson["pointId"].asInt();
    std::string pointName = _paraJson["pointName"].asString();
    int pointNum = _paraJson["pointNum"].asInt();
    int armPosition = _paraJson["armPosition"].asInt();
    int pddDis = _paraJson["pddDis"].asInt();
    Json::Value *sharedJson = getSharedParaJson();
    Motor *pMotor = Motor::getInstance();
    PDDMotorDriver *pPddMotor = PDDMotorDriver::getInstance();
    if(sharedJson == NULL) {
        printf("TakePicCommand::%s(), can't get json value!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " can't get json value! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }
    if ((*sharedJson)[JSON_EXEC_RESULT].asInt() != ST_SUCCESS) {
        printf("TakePicCommand::%s(), last command execute failed, exit!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " last command execute failed, exit! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }
    int execId = (*sharedJson)[JSON_EXEC_ID].asInt();
	Robot *pRobot = Robot::getInstance();
    bool arm_lift = SettingService::getInstance()->m_setting.getArmLiftMoving();
    bool ptz_rotate = SettingService::getInstance()->m_setting.getPtzSwitch();

	setExeRet(ST_GOING);
    switch(_exeStatus)
	{
		case TAKEPIC_ST_ROTATE:
		{
            //升降臂移动到预置点
            if((prearmPos != armPosition) || arm_lift){
                Motor *pMotor = Motor::getInstance();
                pMotor->armMoveTo(armPosition);
            }

            int nRet = -1, nTry = 0;
            while (nRet != 0 && nTry < 3) {
                nTry++;
                nRet = pRobot->m_pIndustrialCamera->presetOperation(GOTO_PRESET, presetNumber);
                printf("TakePicCommand::%s(), presetOperation, number: %d, nRet: %d\n", __FUNCTION__, presetNumber, nRet);
                LOG4CPLUS_INFO(logger, " presetOperation, number: " << presetNumber << ", nRet: " << nRet);
                if (nRet != 0) {
                    sleep(1);
                }
            }

            pRobot->m_nPhotoIndex = 0;
            if(execId < 0) {
                setExeRet(ST_FAIL);
                printf("TakePicCommand::%s(), __LINE__ = %d: no exec id, return!\n", __FUNCTION__, __LINE__);
                LOG4CPLUS_ERROR(logger, " no exec id, return! ");
                break;
            }
            if(pddDis == 0){
                _exeStatus = TAKEPIC_ST_WAIT;
            }
            else{
                nRet = pPddMotor->gotoPosition(pddDis);
                printf("TakePicCommand::%s(), pddMotor, nRet: %d\n", __FUNCTION__, nRet);
                LOG4CPLUS_INFO(logger, "TakePicCommand, pddMotor " << ", nRet: " << nRet);
                _exeStatus = PDD_ST_WAIT;
            }
			clearTimer();
			break;
		}
		case TAKEPIC_ST_WAIT:
		{   
            if((preVPsetNum == presetNumber) && (prearmPos == armPosition) && (!arm_lift) && (!ptz_rotate)){    //云台不回正，云台位置不变， 升降臂不回正，升降臂位置不变化
                _exeStatus = TAKEPIC_ST_CAPTURE;
                std::cout << "m_pMotor->getArmCurPosition(): " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId << std::endl;
                LOG4CPLUS_INFO(logger, " presetOperation, ArmPosition: " << armPosition << ", ArmCurPosition: " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId);
            }
            else if((preVPsetNum == presetNumber) && (!ptz_rotate)&& ((prearmPos != armPosition) || arm_lift))  //云台不回正，云台位置不变， 升降臂回正或升降臂位置变化    
			{
                if(0 == sleeepWaitTimeOut(10)) //1s循环等待升降臂到达
                {
                    if(pMotor->isInState( LIFT_MOTOR, STOP_STATE))
                    {
                        prearmPos = armPosition;
                        _exeStatus = TAKEPIC_ST_CAPTURE;
                        std::cout << "m_pMotor->getArmCurPosition(): " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId << std::endl;
                        LOG4CPLUS_INFO(logger, " presetOperation, ArmPosition: " << armPosition << ", ArmCurPosition: " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId);
                    }
                }
			}
            else if(((preVPsetNum != presetNumber) || ptz_rotate) && (prearmPos == armPosition) && (!arm_lift)) //云台位置变化或者云台回正，升降臂不回正，升降臂位置不变
            {
                if(0 == sleeepWaitTimeOut(100)) //10s等待到达
                {
                    preVPsetNum = presetNumber;
                    _exeStatus = TAKEPIC_ST_CAPTURE;
                    std::cout << "m_pMotor->getArmCurPosition(): " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId << std::endl;
                    LOG4CPLUS_INFO(logger, " presetOperation, ArmPosition: " << armPosition << ", ArmCurPosition: " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId);
                }
            }
            else{                             
                if(0 == sleeepWaitTimeOut(10)) //1s循环等待升降臂到达
                {
                    time_cnt++;
                    if(pMotor->isInState( LIFT_MOTOR, STOP_STATE))
                    {
                        prearmPos = armPosition;
                        if (time_cnt > 10)
                        {
                            _exeStatus = TAKEPIC_ST_CAPTURE;
                            clearTimer();
                            time_cnt = 0;
                            std::cout << "m_pMotor->getArmCurPosition(): " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId << std::endl;
                            LOG4CPLUS_INFO(logger, " presetOperation, ArmPosition: " << armPosition << ", ArmCurPosition: " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId);
                        }
                        else{
                            _exeStatus = PTZ_ST_CAPTURE;
                        }
                    }
                }
            }
			break;
		}
        case PTZ_ST_CAPTURE:
		{
            if(0 == sleeepWaitTimeOut(100 - time_cnt*10)){
                time_cnt = 0;
                clearTimer();
                if(pddDis == 0){
                    _exeStatus = TAKEPIC_ST_CAPTURE;
                }
                else{
                    _exeStatus = PDD_ST_CAPTURE;
                }
                std::cout << "m_pMotor->getArmCurPosition(): " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId << std::endl;
                LOG4CPLUS_INFO(logger, " presetOperation, ArmPosition: " << armPosition << ", ArmCurPosition: " << pMotor->getArmCurPosition() << ", pointName: " << pointName << ", pointId:" << pointId);
            }
			break;
		}
		case TAKEPIC_ST_CAPTURE:
		{
            //设置本地和服务器上传路径
            //品牌_数据源类型_巡检点名称_文件类型_时间戳.jpg
            //数据源类型：wc（广角）、ic（红外）、dc（深度）
            //文件类型：pic（图片）、data（数据文件）、video（视频文件）
			std::string camFileName, thFileName, tempFileName;
            time_t tim;
            time(&tim);
            struct tm* tTime = localtime(&tim);
            char timestamp[20] = "";
            snprintf(timestamp, sizeof(timestamp), "%04d%02d%02d%02d%02d%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, tTime->tm_hour, tTime->tm_min, tTime->tm_sec);

			camFileName += "tetraelc_wc_" + pointName + "_pic_" + timestamp + ".jpg";
            thFileName +=  "tetraelc_ic_" + pointName + "_pic_" + timestamp + ".jpg";
            tempFileName += "tetraelc_ic_" + pointName + "_data_" + timestamp;

            std::string localCameraPic = pRobot->m_sPhotoRootPathDate + "/" + camFileName;
            std::string localThermalPic = pRobot->m_sPhotoRootPathDate + "/" + thFileName; 
            std::string localTempFile = pRobot->m_sPhotoRootPathDate + "/" + tempFileName; 
			std::string uploadCameraPic = pRobot->m_pSettingService->m_setting.getPicturePath() + "/" + camFileName;
			std::string uploadThermelPic = pRobot->m_pSettingService->m_setting.getPicturePath() + "/" + thFileName;

            //本地保存路径不存在，则新建
            if(access(pRobot->m_sPhotoRootPathDate.c_str(), F_OK) != 0) {
                char cmd[1024] = "";
                snprintf(cmd, sizeof(cmd), "mkdir -p %s", pRobot->m_sPhotoRootPathDate.c_str());
                system(cmd);
                printf("TakePicCommand::%s(), %s\n", __FUNCTION__, cmd);
                LOG4CPLUS_INFO(logger, LOG4CPLUS_C_STR_TO_TSTRING(cmd));
            }

            //拍照
            int nCameraRet = -1, nThermalRet = -1, nTempRet = -1, nTry;
            nTry = 0;
            while (nCameraRet != 0 && nTry < 3) {
                nTry++;
                nCameraRet = pRobot->m_pIndustrialCamera->takePicture( const_cast<char*>(localCameraPic.c_str()) );
                printf("TakePicCommand::%s(), local cameraPic path: %s, nRet: %d\n", __FUNCTION__, localCameraPic.c_str(), nCameraRet);
                LOG4CPLUS_INFO(logger, " local cameraPic path: "<< localCameraPic << ", nRet: " << nCameraRet);
                if (nCameraRet != 0) {
                    sleep(1);
                }
            }
            
            nTry = 0;
            while (nThermalRet != 0 && nTry < 3) {
                nTry++;
                nThermalRet = pRobot->m_pThermalImager->takePicture( const_cast<char*>(localThermalPic.c_str()) );
                printf("TakePicCommand::%s(), local thermalPic path: %s, nRet: %d\n", __FUNCTION__, localThermalPic.c_str(), nThermalRet);
                LOG4CPLUS_INFO(logger, " local thermalPic path: "<< localThermalPic << ", nRet: "<< nThermalRet);
                if (nThermalRet != 0) {
                    sleep(1);
                }
            }
            
            //上传到服务器
            PictureInfo pictureInfo;
            pictureInfo.nRobotId = pRobot->m_nRobotID;
            pictureInfo.position = pRobot->m_pMotor->getCurPosition();
            ConfigServer *pConfigServer = ConfigServer::getInstance();
            std::string serverIp = pConfigServer->getMySQLInfo()->sIp;
            
            char cmd[1024] = "";
            if(nCameraRet == 0) {
                snprintf(cmd, 1024, "scp %s root@%s:%s", localCameraPic.c_str(), serverIp.c_str(), uploadCameraPic.c_str());
                nCameraRet = system(cmd);
                printf("TakePicCommand::%s(), %s, nRet: %d\n", __FUNCTION__, cmd, nCameraRet);
                LOG4CPLUS_INFO(logger, " "<< LOG4CPLUS_C_STR_TO_TSTRING(cmd) << ", nRet: "<< nThermalRet);
                pictureInfo.path = uploadCameraPic;
                pRobot->m_pMySQLServer->recordPictureInfo(pictureInfo);

                if (ConfigServer::getInstance()->isNewHope()) {
                    char uploadDir[50] = "";
                    char uploadFilePath[100] = "";
                    snprintf(uploadDir, sizeof(uploadDir), "/tc/%04d%02d%02d/tetra-gaotang-robot%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, pRobot->m_nRobotID);
                    snprintf(uploadFilePath, sizeof(uploadFilePath), "%s/%s", uploadDir, camFileName.c_str());
                    std::vector<std::string> fileList = { camFileName };

                    ftpRemoteUpload(pRobot->m_sPhotoRootPathDate, fileList, uploadDir);
                    CHttpPost::SendViewPointInf(pRobot->m_nRobotID, pointName, execId, uploadFilePath, "wide_camera");  
                }
            }

            if(nThermalRet == 0) {
                snprintf(cmd, 1024, "scp %s root@%s:%s", localThermalPic.c_str(), serverIp.c_str(), uploadThermelPic.c_str());
                nThermalRet = system(cmd);
                printf("TakePicCommand::%s(), %s, nRet: %d\n", __FUNCTION__, cmd, nThermalRet);
                LOG4CPLUS_INFO(logger, " "<< LOG4CPLUS_C_STR_TO_TSTRING(cmd) << ", nRet: "<< nThermalRet);
                pictureInfo.path = uploadThermelPic;
                pRobot->m_pMySQLServer->recordPictureInfo(pictureInfo);

                if (ConfigServer::getInstance()->isNewHope()) {
                    char uploadDir[50] = "";
                    char uploadFilePath[100] = "";
                    snprintf(uploadDir, sizeof(uploadDir), "/tc/%04d%02d%02d/tetra-gaotang-robot%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, pRobot->m_nRobotID);
                    std::vector<std::string> fileList = { thFileName };


                    ftpRemoteUpload(pRobot->m_sPhotoRootPathDate, fileList, uploadDir);

                    snprintf(uploadFilePath, sizeof(uploadFilePath), "%s/%s", uploadDir, thFileName.c_str());
                    CHttpPost::SendViewPointInf(pRobot->m_nRobotID, pointName, execId, uploadFilePath, "infra_camera");  
                }
            }
            if (ConfigServer::getInstance()->isNewHope()) {
                HIKClient *pClient = HIKClient::getInstance();
                nTry = 0;
                while (nTempRet != 0 && nTry < 3) {
                    nTry++;
                    nTempRet = pClient->getTempFile((char*)localTempFile.c_str());
                    printf("TakePicCommand::%s(), local tempPic path: %s, nRet: %d\n", __FUNCTION__, localTempFile.c_str(), nTempRet);
                    LOG4CPLUS_INFO(logger, " local tempPic path: "<< localTempFile << ", nRet: "<< nTempRet);
                    if (nTempRet != 0) {
                        sleep(1);
                    }
                }
                if (nTempRet == 0) {
                    char uploadDir[50] = "";
                    snprintf(uploadDir, sizeof(uploadDir), "/tc/%04d%02d%02d/tetra-gaotang-robot%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, pRobot->m_nRobotID);
                    std::vector<std::string> fileList = { tempFileName };

                    ftpRemoteUpload(pRobot->m_sPhotoRootPathDate, fileList, uploadDir);

                    char uploadFilePath[100] = "";
                    snprintf(uploadFilePath, sizeof(uploadFilePath), "%s/%s", uploadDir, tempFileName.c_str());
                    CHttpPost::SendViewPointInf(pRobot->m_nRobotID, pointName, taskId, uploadFilePath, "hm_data");  
                }
            }

			//插入任务运行日志记录
            viewPointInfo.nTaskId = taskId;
            viewPointInfo.nExecId = execId;
			viewPointInfo.nViewPointId = pointId;

			viewPointInfo.fTemperature = pRobot->m_pSensorBoardEx->getEnvInfo().fTemperature;
			viewPointInfo.fHumidity = pRobot->m_pSensorBoardEx->getEnvInfo().fHumidity;
			viewPointInfo.fCombustible = pRobot->m_pSensorBoardEx->getGasInfo().fCH4;
			viewPointInfo.fCO = pRobot->m_pSensorBoardEx->getGasInfo().fCO;
			viewPointInfo.fH2S = pRobot->m_pSensorBoardEx->getGasInfo().fSO2;
			viewPointInfo.fO2 = pRobot->m_pSensorBoardEx->getGasInfo().fO2;

			viewPointInfo.fThermelMaxTemp = pRobot->m_pThermalImager->getMaxTemp();
			viewPointInfo.strCameraPhotoPath = uploadCameraPic.c_str();
			viewPointInfo.strThermelPhotoPath = uploadThermelPic.c_str();
            viewPointInfo.nposition = Motor::getInstance()->getCurPosition();
            viewPointInfo.TEV = 0;
            viewPointInfo.UW = 0;
			pRobot->m_pMySQLServer->recordViewPointInfo(viewPointInfo);	

            if (nCameraRet >= 0) {
                std::list<EquInfo> equInfoList;
                //查询当前巡检点所有设备
                pRobot->m_pMySQLServer->queryPointEquInfo(viewPointInfo, equInfoList);

                //请求图像识别
                std::vector<CHttpPost::IdentifyResult> resultList;
                if (CHttpPost::GetImageProRes(transId, viewPointInfo.nViewPointId, uploadCameraPic.c_str(), resultList) == 0) {
                    for(auto result: resultList) {
                        //告警判断
                        if (equInfoList.size() <= 0) {
                            printf("TakePicCommand::%s(), no remain equipment!\n", __FUNCTION__);
                            break;
                        }
                        auto equIter = equInfoList.begin();
                        double alarmValue, alarmMin, alarmMax;
                        if (equIter->nAlarmDType <= 3) {
                            alarmValue = atof(result.value.c_str());
                            alarmMin = atof(equIter->sAlarmMin.c_str());
                            alarmMax = atof(equIter->sAlarmMax.c_str());
                        }
                        printf("TakePicCommand::%s(), alarmValue: %s, min: %f, max: %f, alarmType: %d, innerId: %d, equId: %d\n", __FUNCTION__, result.value.c_str(), alarmMin, alarmMax, equIter->nAlarmDType, equIter->nInnerId, equIter->nEquId);
                        result.isAlarm = false;
                        switch (equIter->nAlarmRule) {
                            case EQU_ALARM_BT:
                                if (alarmValue > alarmMax) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_LT:
                                if (alarmValue < alarmMax) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_EQ:
                                if (alarmValue == alarmMax) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_BE:
                                if (alarmValue >= alarmMax) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_LE:
                                if (alarmValue <= alarmMax) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_RANGE:
                                if ((alarmValue >= alarmMin) && 
                                    (alarmValue <= alarmMax)) {
                                    result.isAlarm = true;
                                }
                                break;
                            case EQU_ALARM_IN:
                                printf("TakePicCommand::%s(), see IN next time!\n", __FUNCTION__);
                                break;
                            case EQU_ALARM_NOTIN:
                                printf("TakePicCommand::%s(), see NOTIN next time!\n", __FUNCTION__);
                                break;
                            default:
                                break;
                        }
                        
                        //记录识别结果
                        pRobot->m_pMySQLServer->recordImageIdentifyResult(viewPointInfo, *equIter, result);
                        equInfoList.pop_front();
                    }
                }

                printf("TakePicCommand::%s(), transId: %d, pointId: %d, execId: %d\n", __FUNCTION__, transId, pointId, execId);
                LOG4CPLUS_INFO(logger, " transId: "<< transId << ", pointId: "<< pointId << ", execId: " << execId);
                transId++;
            }

            //结果更新
            if(pointNum & 1<<POINT_LAST) {        //本次任务最后一个巡检点
                //写本次任务执行结果到数据库
                pRobot->m_pMySQLServer->changeExecResult(viewPointInfo);	
            }
            pRobot->m_nPhotoIndex++;
            snprintf(cmd, 1024, "rm -r %s", pRobot->m_sPhotoRootPathDate.c_str());
            system(cmd);
            printf("TakePicCommand::%s(), %s\n", __FUNCTION__, cmd);
            LOG4CPLUS_INFO(logger, LOG4CPLUS_C_STR_TO_TSTRING(cmd));
            setExeRet(ST_SUCCESS);
			break;
		}
        case PDD_ST_WAIT:
        {
            if(0 == sleeepWaitTimeOut(10)){
                stateBite = pPddMotor->getStat();
                time_cnt++;
                if((stateBite != 4151)&&(pMotor->isInState( LIFT_MOTOR, STOP_STATE)))
                {
                    if (time_cnt > 10){
                        clearTimer();
                        time_cnt = 0;
                        printf("-----@@@@@@@@@@@@@---------@@@@@@@@@@@@--------PDD Cur Pos:%d",pRobot->m_pPDD->getCurPos());
                        pPddMotor->gotoPosition(-10000);
                        _exeStatus = PDD_ST_CAPTURE;
                    }
                    else{
                        printf("-----@@@@@@@@@@@@@---------@@@@@@@@@@@@--------PDD Cur Pos:%d",pRobot->m_pPDD->getCurPos());
                        pPddMotor->gotoPosition(-10000);
                        _exeStatus = PTZ_ST_CAPTURE;
                    }
                }
            }
            break;
        }
        case PDD_ST_CAPTURE:
        {
            //插入任务运行日志记录
            viewPointInfo.nTaskId = taskId;
            viewPointInfo.nExecId = execId;
			viewPointInfo.nViewPointId = pointId;

			viewPointInfo.fTemperature = pRobot->m_pSensorBoardEx->getEnvInfo().fTemperature;
			viewPointInfo.fHumidity = pRobot->m_pSensorBoardEx->getEnvInfo().fHumidity;
			viewPointInfo.fCombustible = pRobot->m_pSensorBoardEx->getGasInfo().fCH4;
			viewPointInfo.fCO = pRobot->m_pSensorBoardEx->getGasInfo().fCO;
			viewPointInfo.fH2S = pRobot->m_pSensorBoardEx->getGasInfo().fSO2;
			viewPointInfo.fO2 = pRobot->m_pSensorBoardEx->getGasInfo().fO2;

			viewPointInfo.fThermelMaxTemp = 0.0;
			viewPointInfo.strCameraPhotoPath = "";
			viewPointInfo.strThermelPhotoPath = "";
            viewPointInfo.nposition = Motor::getInstance()->getCurPosition();
            viewPointInfo.TEV = pRobot->m_pDec->getTEVData();
            viewPointInfo.UW = pRobot->m_pDec->getUWData();
			pRobot->m_pMySQLServer->recordViewPointInfo(viewPointInfo);	
            setExeRet(ST_SUCCESS);
            break;
        }
		default:
		{
            setExeRet(ST_FAIL);
			break;
		}
	}
    return _exeRet;
}
