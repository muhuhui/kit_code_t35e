//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : RechargeCommand.cpp
//  @ Date : 2019-06-25
//  @ Author : ShunWang
//
//


#include "RechargeCommand.h"
#include "Driver/BatteryDriver.h"
#include "Transaction/Motor.h"
#include "Transaction/ConfigServer.h"
#include "Transaction/SettingService.h"
#include "Driver/ChargePileDriver.h"
#include "Driver/MyLog4CXX.h"
#include <unistd.h>
#include "Transaction/Motor.h"

const std::string LOG_TAG("root.RechargeCommand::");

int RechargeCommand::exec()
{
    auto logger = initLogger(LOG_TAG + std::string(__FUNCTION__));
	BatteryDriver* batteryDriver = BatteryDriver::getInstance();
    SettingService *settingService = SettingService::getInstance();
    ChargePileDriver *pChargeDrvier = ChargePileDriver::getInstance();
    Motor* pMotor = Motor::getInstance();
    float quantityMinLimit = settingService->m_setting.getBatteryQuantityMin();
    int chargeType = _paraJson["charge_type"].asInt();
    float destPos = _paraJson["destPos"].asFloat();
    
    if (_exeRet != ST_SUCCESS && _exeRet != ST_FAIL)
    {
        switch(_exeStatus)
        {
            case RECHARGE_START:
            {
                if(batteryDriver->getCurrent() > 0.5) {  //正在充电，直接退出
                    printf("RechargeCommand::exec(), already in charging\n");
                    LOG4CPLUS_INFO(logger, "already in charging");
                    setExeRet(ST_SUCCESS);
                    return _exeRet;
                }
                if(0 == sleeepWaitTimeOut(5)) {
                    int nRet = pChargeDrvier->gotoCharge((int)destPos);
                    printf("RechargeCommand::exec(), gotocharge pos: %f, nRet: %d\n", destPos, nRet);
                    LOG4CPLUS_INFO(logger, "gotocharge pos: " << destPos << ", nRet: " << nRet);
                    if (nRet != 0) {
                        _tryCnt++;
                        if (_tryCnt >= 5) {
                            setExeRet(ST_FAIL);
                            _tryCnt = 0;
                        }
                        printf("RechargeCommand::exec(), gotocharge failed, retry: %d\n", _tryCnt);
                        LOG4CPLUS_INFO(logger, "gotocharge failed, retry: " << _tryCnt);
                        break;
                    }
                    _tryCnt = 0;
                    clearTimer();
                    _exeStatus = RECHARGE_CHECK;
                }
            }
            break;
            case RECHARGE_CHECK:
            {
                if(0 == sleeepWaitTimeOut(20)) {
                    ChargeInfo info;
                    int nRet = pChargeDrvier->getChargeInfo(info);
                    if (nRet == 0) {
                        if (info.chargeStat == CP_IN_SEARCHING) {
                            printf("RechargeCommand::exec(), search for charging, stat: %d\n", info.chargeStat);
                            LOG4CPLUS_INFO(logger, "search for charging, stat: " << info.chargeStat);

                            if(true == pMotor->isInState(WALK_MOTOR,STOP_STATE)) {
                                if(_tryCnt < 3) {
                                    int nRet = pChargeDrvier->gotoCharge((int)destPos);
                                    printf("RechargeCommand::exec(), gotocharge pos: %f, nRet: %d\n", destPos, nRet);
                                    LOG4CPLUS_INFO(logger, "gotocharge pos: " << destPos << ", nRet: " << nRet);
                                    _tryCnt++;
                                }
                                else{
                                    _tryCnt = 0;
                                    printf("RechargeCommand::exec(), charge over, stat: %d\n", info.chargeStat);
                                    LOG4CPLUS_INFO(logger, "charge over, stat: " << info.chargeStat);
                                    setExeRet(ST_FAIL);
                                    return _exeRet;
                                }
                            }
                        }
                        else if (info.chargeStat == CP_IN_CHARGING) {
                            _tryCnt = 0;
                            if (chargeType == MANUAL_CHARGE) {
                                setExeRet(ST_SUCCESS);
                                return _exeRet;
                            }
                            //最低电量+10，结束任务
                            if (batteryDriver->getQuantity() >= (quantityMinLimit + 10) || batteryDriver->getQuantity() >= 98) {
                                printf("RechargeCommand::exec(), charge over, stat: %d\n", info.chargeStat);
                                LOG4CPLUS_INFO(logger, "charge over, stat: " << info.chargeStat);
                                setExeRet(ST_SUCCESS);
                                return _exeRet;
                            }
                        }
                        else if (info.chargeStat == CP_CHARGE_FULL) {
                            _tryCnt = 0;
                            printf("RechargeCommand::exec(), charge full, stat: %d\n", info.chargeStat);
                            LOG4CPLUS_INFO(logger, "charge full, stat: " << info.chargeStat);
                            setExeRet(ST_SUCCESS);
                            return _exeRet;
                        }
                        else if (info.chargeStat == CP_CHARGE_FAIL || info.chargeStat == CP_NOT_IN_CHARGE) {
                            _tryCnt = 0;
                            printf("RechargeCommand::exec(), charge failed, stat: %d\n", info.chargeStat);
                            LOG4CPLUS_INFO(logger, "charge failed, stat: " << info.chargeStat);
                            setExeRet(ST_FAIL);
                            return _exeRet;
                        }
                        else {
                            _tryCnt = 0;
                            setExeRet(ST_FAIL);
                            return _exeRet;
                        }
                    }
                }
            }
            break;
            default:
            break;
        }
    }
    return _exeRet;
}

