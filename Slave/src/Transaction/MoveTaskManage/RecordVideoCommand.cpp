//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : TakePhotoCommand.cpp
//  @ Date : 2019-07-02
//  @ Author : ShunWang
//
//

#include "RecordVideoCommand.h"
#include "Transaction/Robot.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include "Common/HttpPost/CHttpPost.hpp"
#include "Poco/Net/HTTPResponse.h"
#include "Poco/StreamCopier.h"
#include <iostream>
#include "Common/FtpClient/CFtpClient.h"
#include "Transaction/ConfigServer.h"
#include "Common/HIKClient/HIKClient.h"
#include "Common/IRAYClient/IRAYClient.h"
#include <vector>
#include <cmath>

const std::string LOG_TAG("root.RecordVideoCommand::");
extern ViewPointInfo patrolViewPointInfo;
extern int videoflag;

int RecordVideoCommand::exec()
{
    std::string logname = LOG_TAG + std::string(__FUNCTION__);
    auto logger = initLogger(logname);

    patrolViewPointInfo.nExecRes = EXEC_SUCCESS;

    //解析JSON参数
	int taskId = _paraJson["taskId"].asInt();
	int pointId = _paraJson["pointId"].asInt();
    std::string pointName = _paraJson["pointName"].asString();
    Robot *pRobot = Robot::getInstance();
    int duration = pRobot->m_pConfigServer->getTimeInfo()->VideoDuration;
    Json::Value *sharedJson = getSharedParaJson();
    struct timeval start;
    struct timeval end;
    float x1 = _paraJson["x1"].asFloat();
	float y1 = _paraJson["y1"].asFloat();
	float x2 = _paraJson["x2"].asFloat();
	float y2 = _paraJson["y2"].asFloat();
    IRAYClient *pIRAYClient = IRAYClient::getInstance();

    if(sharedJson == NULL) {
        printf("RecordVideoCommand::%s(), can't get json value!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " can't get json value! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }

    if ((*sharedJson)[JSON_EXEC_RESULT].asInt() != ST_SUCCESS) {
        printf("RecordVideoCommand::%s(), last command execute failed, exit!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " last command execute failed, exit! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }
    int execId = (*sharedJson)[JSON_EXEC_ID].asInt();

    if(execId < 0) {
        setExeRet(ST_FAIL);
        printf("RecordVideoCommand::%s(), __LINE__ = %d: no exec id, return!\n", __FUNCTION__, __LINE__);
        LOG4CPLUS_ERROR(logger, " no exec id, return! ");
    }

	setExeRet(ST_GOING);
    switch(_exeStatus)
	{
		case RECORDVIDEO_ST_BEGAIN:
		{
            //设置本地和服务器上传路径
            //品牌_数据源类型_巡检点名称_文件类型_时间戳.jpg
            //数据源类型：wc（广角）、ic（红外）、dc（深度）
            //文件类型：pic（图片）、data（数据文件）、video（视频文件）
			std::string camFileName, thFileName;
            time_t tim;
            time(&tim);
            struct tm* tTime = localtime(&tim);
            char timestamp[20] = "";
            char server_timestamp[20] = "";
            snprintf(timestamp, sizeof(timestamp), "%04d%02d%02d%02d%02d%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday, tTime->tm_hour, tTime->tm_min, tTime->tm_sec);
            snprintf(server_timestamp, sizeof(server_timestamp), "%04d-%02d-%02d", tTime->tm_year + 1900, tTime->tm_mon + 1, tTime->tm_mday);

			camFileName += "tetraelc_wc_" + pointName + "_video_" + timestamp + ".mp4";
            thFileName +=  "tetraelc_ic_" + pointName + "_video_" + timestamp + ".mp4";

            std::string uploadCamera = pRobot->m_pSettingService->m_setting.getVideoPath() + std::to_string(pRobot->m_nRobotID) 
            + "/" + server_timestamp + "/" + "ViewPiontCameraVideo" + "/";
			std::string uploadThermel = pRobot->m_pSettingService->m_setting.getVideoPath() + std::to_string(pRobot->m_nRobotID)
            + "/" + server_timestamp + "/" + "ViewPiontThermelVideo" + "/";
            std::string uploadCameraVideo = uploadCamera + camFileName;
            std::string uploadThermelVideo = uploadThermel + thFileName;

            //调用服务器
            ConfigServer *pConfigServer = ConfigServer::getInstance();
            std::string serverIp = pConfigServer->getMySQLInfo()->sIp;
            std::string hkUserName = pConfigServer->getCameraUserName();
            std::string hkUserPass = pConfigServer->getCameraPassword();
            
            char cmd[1024] = "";
            char dircmd[1024] = "";
            char reccmd[1024] = "";
            char ireccmd[1024] = "";

            snprintf(dircmd, 1024, "[ -d %s -a -d %s ] && echo ok || mkdir -p %s %s", uploadCamera.c_str(), uploadThermel.c_str(), uploadCamera.c_str(), uploadThermel.c_str());
            if(pRobot->m_pConfigServer->getRobotVersion() == "t3e") {
            snprintf(reccmd, 1024, "ffmpeg -y -i rtsp://%s:%s@%s/mpeg4 -f mp4 -t %d %s > /dev/null 2>&1 < /dev/null &", 
                    hkUserName.c_str(), hkUserPass.c_str(), pRobot->m_pSettingService->m_setting.getIndustrialCameraIp().c_str(), duration, uploadCameraVideo.c_str());
            }
            else{
            snprintf(reccmd, 1024, "ffmpeg -y -i rtsp://%s:%s@%s:554/h264/ch1/main/avstream -vcodec copy -strict -2 -f mp4 -t %d %s > /dev/null 2>&1 < /dev/null &", 
                    hkUserName.c_str(), hkUserPass.c_str(), pRobot->m_pSettingService->m_setting.getIndustrialCameraIp().c_str(), duration, uploadCameraVideo.c_str());
            }
            snprintf(ireccmd, 1024, "ffmpeg -y -i rtsp://%s:%s@%s:554/stream0 -vcodec copy -strict -2 -f mp4 -t %d %s > /dev/null 2>&1 < /dev/null &", 
                    "888888", "888888", pRobot->m_pSettingService->m_setting.getThermalImagerIp().c_str(), duration, uploadThermelVideo.c_str());
            //ssh user@192.168.3.131 "[ -d /var/test ] && echo ok || mkdir -p /var/test"
            //ffmpeg -y -i rtsp://UserName:Password@cameraIp:554/h264/ch1/main/avstream -vcodec copy -strict -2 -f mp4  fileName.mp4

            //服务器路径不存在，则新建
            snprintf(cmd, 1024, "%s", dircmd);
            int nCameraRet = system(cmd);
            //连接服务器录制可见光视频
            snprintf(cmd, 1024, "%s", reccmd);
            nCameraRet = system(cmd);
            //连接服务器录制红外视频
            snprintf(cmd, 1024, "%s", ireccmd);
            nCameraRet = system(cmd);

            //插入任务运行日志记录
            patrolViewPointInfo.nTaskId = taskId;
            patrolViewPointInfo.nExecId = execId;
            patrolViewPointInfo.nViewPointId = pointId;

            patrolViewPointInfo.fTemperature = pRobot->m_pSensorBoardEx->getEnvInfo().fTemperature;
            patrolViewPointInfo.fHumidity = pRobot->m_pSensorBoardEx->getEnvInfo().fHumidity;
            patrolViewPointInfo.fCombustible = pRobot->m_pSensorBoardEx->getGasInfo().fCH4;
            patrolViewPointInfo.fCO = pRobot->m_pSensorBoardEx->getGasInfo().fCO;
            patrolViewPointInfo.fH2S = pRobot->m_pSensorBoardEx->getGasInfo().fSO2;
            patrolViewPointInfo.fO2 = pRobot->m_pSensorBoardEx->getGasInfo().fO2;

            patrolViewPointInfo.strCameraVideoPath = uploadCameraVideo.c_str();
            patrolViewPointInfo.strThermelVideoPath = uploadThermelVideo.c_str();
            patrolViewPointInfo.nposition = Motor::getInstance()->getCurPosition();

            gettimeofday(&start,NULL);
            videoflag = 1;
            _exeStatus = RECORDVIDEO_ST_WAIT;
			break;
		}
        case RECORDVIDEO_ST_WAIT:
		{
            if(0 == sleeepWaitTimeOut(10)){
                gettimeofday(&end,NULL);
                int diff = end.tv_sec-start.tv_sec;
                if(diff > duration){
                    _exeStatus = RECORDVIDEO_ST_FINSIH;
                }
            }
			break;
		}
        case RECORDVIDEO_ST_FINSIH:
		{
            videoflag = 0;
            
            std::vector<float> corners = {x1, y1, x2, y2};
            if((abs(corners[0]) < 0.01 && abs(corners[1]) < 0.01 && abs(corners[2]) < 0.01 && abs(corners[3]) < 0.01) ||
               (abs(corners[0] - corners[2]) < 0.01) || (abs(corners[1] - corners[3]) < 0.01)) {
                patrolViewPointInfo.fThermelMaxTemp = 0.0;
                printf("RecordVideoCommand::%s(), succeeded!\n", __FUNCTION__);
                LOG4CPLUS_INFO(logger, " RecordVideoCommand succeeded to excute! " );
                setExeRet(ST_SUCCESS);
                clearTimer();
            }
            else {
                pIRAYClient->get_local_temp(corners);
                patrolViewPointInfo.fThermelMaxTemp = pIRAYClient->getMaxTemp();
                printf("RecordVideoCommand::%s(), succeeded!\n", __FUNCTION__);
                LOG4CPLUS_INFO(logger, " RecordVideoCommand succeeded to excute! " );
                setExeRet(ST_SUCCESS);
                clearTimer();
            }
		}
		default:
		{
            setExeRet(ST_FAIL);
			break;
		}
	}
    return _exeRet;
}