//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : PtzRotateCommand.cpp
//  @ Date : 2019-07-02
//  @ Author : ShunWang
//
//

#include "PtzRotateCommand.h"
#include "Transaction/Robot.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include "Driver/MyLog4CXX.h"
#include "Driver/PTZDriver.h"
#include "Driver/MotorDriver.h"
#include "Transaction/ConfigServer.h"


const std::string LOG_TAG("root.PtzRotateCommand::");

int PtzRotateCommand::exec()
{
    std::string logname = LOG_TAG + std::string(__FUNCTION__);
    auto logger = initLogger(logname);

    int ptzPreset[4] = {0, 0, 0, 0};
    int isReturn = 0;
    std::vector<PTZMotorStat> ptzState;
    ptzState.clear();

    isReturn = _paraJson["isReturn"].asInt();
    if(isReturn == 0) {
        ptzPreset[0] = _paraJson["x_pos"].asInt();
        ptzPreset[1] = _paraJson["y_pos"].asInt();
        ptzPreset[2] = _paraJson["z_pos"].asInt();
        ptzPreset[3] = _paraJson["zoom"].asInt();
    }

	//解析JSON参数
    Robot *pRobot = Robot::getInstance();
    PTZDriver::Ptr pPtzMotor = PTZDriver::getInstance();
    Motor *pMotor = Motor::getInstance();
    SettingService *settingService = SettingService::getInstance();
    int PtzWait = pRobot->m_pConfigServer->getTimeInfo()->PtzRotate;
    float armPos = pMotor->getArmCurPosition();

    Json::Value *sharedJson = getSharedParaJson();

    if(sharedJson == NULL) {
        printf("PtzRotateCommand::%s(), can't get json value!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " can't get json value! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }
    if ((*sharedJson)[JSON_EXEC_RESULT].asInt() != ST_SUCCESS) {
        (*sharedJson)[JSON_EXEC_RESULT] = ST_FAIL;
        printf("PtzRotateCommand::%s(), last command execute failed, exit!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " last command execute failed, exit! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }

    if(armPos <=  20) {
        (*sharedJson)[JSON_EXEC_RESULT] = ST_FAIL;
        printf("PtzRotateCommand::%s(), arm position out of range!\n", __FUNCTION__);
        LOG4CPLUS_ERROR(logger, " arm position out of range! ");
        setExeRet(ST_FAIL);
        return _exeRet;
    }

	setExeRet(ST_GOING);
    switch(_exeStatus)
	{
		case ROTATE_ST_START:
		{
            //云台回零
            int nRet = -1;
            if(0 == sleeepWaitTimeOut(10)) {
                if (isReturn) {
                    nRet = pPtzMotor->ctrlPTZ(HORIZ_MOTOR,TURN_HOME,0);
                    nRet += pPtzMotor->ctrlPTZ(CAM_MOTOR,TURN_HOME,0);
                    nRet += pPtzMotor->ctrlPTZ(INFRA_MOTOR,TURN_HOME,0);
                    printf("PtzArmCommand::%s(), ptz start turn home, nRet: %d\n", __FUNCTION__, nRet);
                    LOG4CPLUS_INFO(logger, " ptz start turn home, nRet: " << nRet);
                }
                else {
                    nRet = pPtzMotor->gotoPreset(ptzPreset, sizeof(ptzPreset)/sizeof(int));
                    printf("PtzArmCommand::%s(), presetOperation, nRet: %d\n", __FUNCTION__, nRet);
                    LOG4CPLUS_INFO(logger, " presetOperation, nRet: " << nRet);
                }
                if (nRet == 0) {
                    _tryCnt = 0;
                    clearTimer();
                    _exeStatus = ROTATE_ST_WAIT;
                }
                _tryCnt++;
                if (_tryCnt > 5) {
                    printf("PtzArmCommand::%s(), preset Operation failed, try: %d\n", __FUNCTION__, _tryCnt);
                    LOG4CPLUS_INFO(logger, " presetOperation failed, try: " << _tryCnt);
                    setExeRet(ST_FAIL);
                    break;
                }
            }
			break;
		}
        case ROTATE_ST_WAIT:
		{
            if(0 == sleeepWaitTimeOut(PtzWait)) {//1s等待到达
                _tryCnt++;
                if (_tryCnt > 30) {
                    setExeRet(ST_FAIL);
                    printf("PtzRotateCommand::%s(), wrong status, exit\n", __FUNCTION__);
                    LOG4CPLUS_INFO(logger, " wrong status, exit");
                }

                int nRet = pPtzMotor->getPTZStatus(ptzState);
                if (nRet != 0 || ptzState.size() < 3) {
                    break;
                }

                if (ptzState[0].moveStat == STOPPED && ptzState[1].moveStat == STOPPED && ptzState[2].moveStat == STOPPED) {
                    if (fabs(ptzState[0].angle - ptzPreset[0]) < 5
                        && fabs(ptzState[1].angle - ptzPreset[1]) < 5
                        && fabs(ptzState[2].angle - ptzPreset[2]) < 5) {
                        _exeStatus = ROTATE_ST_FINISH;
                    }
                }
            }
			break;
		}
		case ROTATE_ST_FINISH:
		{
            clearTimer();
            (*sharedJson)[JSON_EXEC_RESULT] = ST_SUCCESS;
            LOG4CPLUS_INFO(logger, "go to presetOperation succeed");
            setExeRet(ST_SUCCESS);
            break;
        }
		default:
		{
            (*sharedJson)[JSON_EXEC_RESULT] = ST_FAIL;
            setExeRet(ST_FAIL);
			break;
		}
	}
    return _exeRet;
}
