//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : T3C_SLAVE
//  @ File Name : MoveTaskItem.cpp
//  @ Date : 2019-06-25
//  @ Author : ShunWang
//
//


#include "MoveTaskItem.h"
#include "Command.h"
#include <vector>
#include <algorithm>
#include <time.h>
#include "Driver/MyLog4CXX.h"

const std::string LOG_TAG("root.MoveTaskItem::");

MoveTaskItem::MoveTaskItem(ItemType type):m_itemType(type)
{
    m_isActive = false;
    m_exceptionVect.clear();
    time_t nowTime;
    time(&nowTime);
    setCreateTime(nowTime);
}

MoveTaskItem::~MoveTaskItem()
{
}

int MoveTaskItem::run() 
{
	auto logger = initLogger(LOG_TAG + std::string(__FUNCTION__));

	if(ST_SUCCESS != (*curIter)->getExeRet() && ST_FAIL != (*curIter)->getExeRet()) //任务尚未执行完，循环执行该函数
	{
        if(curIter == _commands.begin() && ST_SLEEP == (*curIter)->getExeRet()) {   //首次执行，激活将执行的任务
			printf("--- MoveTaskItem::%s(), __LINE__= %d: executing %s...\n",__FUNCTION__, __LINE__, (*curIter)->name.c_str());
			LOG4CPLUS_INFO(logger, " executing " <<  (*curIter)->name.c_str());
            (*curIter)->setExeRet(ST_GOING);
            activate();
        }
		(*curIter)->exec();
	}
	else
	{
		curIter++;
        if(curIter!=_commands.end())
		{
			printf("--- MoveTaskItem::%s(), __LINE__= %d: executing %s...\n",__FUNCTION__, __LINE__, (*curIter)->name.c_str());
			LOG4CPLUS_INFO(logger, " executing " <<  (*curIter)->name.c_str());
            (*curIter)->setExeRet(ST_GOING);
			(*curIter)->exec();
		}
		else
		{
			printf("--- MoveTaskItem::%s(), __LINE__= %d: commands finished.\n", __FUNCTION__, __LINE__);
			LOG4CPLUS_INFO(logger, " commands finished. " );
            deactivate();               //成功结束时才失活
			clearCommands();
		}
	}
}

void MoveTaskItem::addCommand(Command* command) 
{
	_commands.push_back(command);
}

void MoveTaskItem::clearCommands() 
{
    for(std::vector<Command*>::iterator iter=_commands.begin();iter!=_commands.end();++iter)
    {
        delete(*iter);
    }
	_commands.clear();
}

//查询动作
Command* MoveTaskItem::queryCommand(int index)
{
	Command* command = NULL;
	if(index >=0 && index <_commands.size())
	{
		 command = _commands[index];
	}
	return command;
}

MoveTaskComponent* MoveTaskItem::findLeftMostChild()
{
	return this;
}

//初始化状态参数
void MoveTaskItem::initStatusPara()
{
	if(_commands.size() > 0)
	{
        curIter = _commands.begin();
	    for(std::vector<Command*>::iterator iter=_commands.begin();iter!=_commands.end();++iter)
		{
			(*iter)->initStatusPara();
		}
	}
}

void MoveTaskItem::init()
{
	_commands.clear();
}

int MoveTaskItem::getChildSize()
{
	return 0;
}

MoveTaskComponent* MoveTaskItem::getChild(int index)
{
    return NULL;
}


int MoveTaskItem::registerException(Exception *exception)
{
	std::string logname = LOG_TAG + std::string(__FUNCTION__);
	auto logger = initLogger(logname);
    if(exception == nullptr) { 
        printf("MoveTaskItem::%s(), exception is null!\n", __FUNCTION__);
		LOG4CPLUS_INFO(logger, "exception is null!");
        return -1; 
    }

    std::vector<Exception*>::iterator iter = find(m_exceptionVect.begin(), m_exceptionVect.end(), exception);
    if(iter != m_exceptionVect.end()) { 
        printf("MoveTaskItem::%s(), exception has already registered!\n", __FUNCTION__);
		LOG4CPLUS_INFO(logger, " exception has already registered! ");
        return 0; 
    }

    m_exceptionVect.push_back(exception);
    return 0;
}

void MoveTaskItem::exceptionsExit()
{
    for(std::vector<Exception*>::iterator iter = m_exceptionVect.begin(); iter != m_exceptionVect.end(); iter++) {
        (*iter)->exceptionExit();
        delete (*iter);
    }
    m_exceptionVect.clear();
    deactivate();
}


